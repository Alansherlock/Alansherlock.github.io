[{"title":"对于vue中$nextTick的理解","date":"2018-07-23T03:05:04.403Z","path":"2018/07/23/vue中nextTick/","text":"input输入限制只能输入小数遇到的问题改了我半天发现是需要利用到$nextTick,翻开了下vue的文档关于$nextTick的解释，如下： 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。 要理解的关键概念是DOM是异步更新的。在Vue中更改值时，更改不会立即呈现给DOM。相反，Vue将DOM更新排队，然后在计时器上更新DOM。通常，这种情况发生得如此之快以至于没有什么区别，但是，有时候，你需要在Vue渲染后更新渲染的DOM，你不能立即在方法中做，因为更新没有发生然而。在那些情况下，你会使用nextTick。来自对于$nextTick的理解 为什么会这样？ 看了染陌大佬的$nextTick解析中有这样一段12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt; &lt;div @click=\"handleClick\"&gt;click&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; number: 0 &#125;; &#125;, methods: &#123; handleClick () &#123; for(let i = 0; i &lt; 1000; i++) &#123; this.number++; &#125; &#125; &#125;&#125;&lt;/script&gt; 当我们按下 click 按钮的时候，number 会被循环增加1000次。 那么按照之前的理解，每次 number 被 +1 的时候，都会触发 number 的 setter 方法，从而根据上面的流程一直跑下来最后修改真实 DOM。那么在这个过程中，DOM 会被更新 1000 次！太可怕了。 Vue.js 肯定不会以如此低效的方法来处理。Vue.js在默认情况下，每次触发某个数据的 setter 方法后，对应的 Watcher 对象其实会被 push 进一个队列 queue 中，在下一个 tick 的时候将这个队列 queue 全部拿出来 run（ Watcher 对象的一个方法，用来触发 patch 操作） 一遍。因为目前浏览器平台并没有实现 nextTick 方法，所以 Vue.js 源码中分别用 Promise、setTimeout、setImmediate 等方式在 microtask（或是task）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。——&lt;–摘自染陌掘金小册–&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://Alansherlock.github.io/tags/vue/"}]},{"title":"webpack加快热更新","date":"2018-07-23T02:55:05.080Z","path":"2018/07/23/wepack加快热更新/","text":"在项目开始的时候，文件还不会很多，我们都没关心热更新的问题，到了大的时候就编译热更新坐在那里等个好久，我说的好久可能大家的都不一样，哈哈哈；接下来，介绍一些小技巧，往后发现就会继续追更，emmm,嘻嘻 技巧一：利用babel-loader缓存参数12345678910111213module.exports = &#123; module: &#123; noParse: /node_modules\\/(jquey|moment|chart\\.js)/, rules: [ &#123; test: /\\.js$/, loader: 'babel-loader?cacheDirectory', include: [resolve('src'), resolve('test')], exclude:/node_modules/ &#125;, ] &#125;&#125; 项目往后需要编译的文件更多，因此我们从babel-loader下手 由于项目开的时候用的是webpack2.x的版本，但是百度后3.x的这个属性依旧是可以用的，会使之前的热更新加快的其中一个点；忽略编译node_modules,使解析babel-loader再快 技巧二：忽略掉一些大的node_modules里面的模块123456module.exports = &#123; module: &#123; //这里列出一些模块，根据自己项目去除一些编译的文件 noParse: /node_modules\\/(jquey|moment|chart\\.js)/, &#125;&#125;","tags":[{"name":"webpack","slug":"webpack","permalink":"https://Alansherlock.github.io/tags/webpack/"}]},{"title":"vue+axios 上传七牛云图片","date":"2018-07-23T02:43:50.559Z","path":"2018/07/23/七牛云上穿图片/","text":"vue+axios 上传七牛云图片 vue+axios 上传七牛云图片图片上传${base}为项目路径QiNiu.upUrl为自己项目的七牛云线上地址Base64.encode(setImgKey())为key值做处理，便于以后删除不是生产服的线上图片具体可以参考七牛云官网12345678910111213141516171819202122232425262728293031323334353637383940414243444546//获取七牛云上传token,此处是后台写的接口获取的token的接口export const getUploadToken = params =&gt; &#123; return axios.get(`$&#123;base&#125;/v1/api/public/getUploadToken`, &#123;params: &#123;...params&#125;&#125;, config);&#125;;//上传图片的接口export const upDetailImg = (params, con) =&gt; &#123; function setImgKey() &#123; const storeId = JSON.parse(sessionStorage.getItem('isLogin')).userId; const date = +new Date() + ''; return storeId + '_' + _env + '_' + md5(storeId + date); &#125; return axios.post(QiNiu.upUrl + '/putb64/-1/key/' + Base64.encode(setImgKey()) + '/', params, con)&#125;,imgUpload(e) &#123; //当前的项目的APPID，来获取七牛上传的token let params = &#123; appId: \"c4805e2dcc\" &#125;; const file = e.target.files;//拿到当前上传的文件数组； for (let i = 0; i &lt; file.length; i++) &#123;//可以对该数组中上传的每一个文件进行文件的大小判断进而做限制 if (file[i].size &gt; 5000000) &#123; return false; &#125; //在执行当前接口获取token的同时new 一个FromData，然后执行需要上传的参数，从而将图片上传； getUploadToken(params).then(res =&gt; &#123; this.img_name.token = res.data.uptoken; var params2 = new FormData(); params2.append(\"file\", file[i]); params2.append(\"token\", res.data.uptoken); params2.append(\"key\", this.setImgKey()); upDetailImgs(params2, &#123;&#125;).then(result =&gt; &#123; const _imgUrl =config.qiniu.baseUrl + result.data.key; this.img_list.push(_imgUrl); &#125;); &#125;); &#125;&#125;,//md5图片上传Key的拼接，获取的是当前的用户Id，以及当前时间，拼接成一个唯一的key值；在以后自己的获取中，如果没有做这个七牛也会随机的生成key，不必拼接；setImgKey() &#123; const storeId = JSON.parse(sessionStorage.getItem(\"isLogin\")).userId; const date = +new Date() + \"\"; return storeId + \"_\" + _env + \"_\" + md5(storeId + date);&#125; 以上就是在项目中用到的图片上传的一个函数； input type = &#39;file&#39;,input的类型为文件类型 accept = &#39;image/png,image/jpeg,image/jpg,image/gif&#39;,限制图片的上传类型， file[i].size，限制图片的上传大小，在设置了多选之后，file为一个数组，因此，需要用for循环对每一个进行判断","tags":[{"name":"vue","slug":"vue","permalink":"https://Alansherlock.github.io/tags/vue/"}]},{"title":"webpack-todo二","date":"2018-07-23T02:23:35.260Z","path":"2018/07/23/webpack-todo二/","text":"webpack构建可通用的配置文件 简单的静态资源的基本配置配置时候注意转义点.include:[]12345678910111213141516171819202122232425262728293031323334353637383940414243444546const config = &#123; module: &#123; rules: [ &#123; test:/\\.css$/, loader:'css-loader' &#125;, &#123; test:/\\.vue$/, loader:'vue-loader' &#125;, &#123; test:/\\.css$/, use:[ 'style-loader', 'css-loader' ], include: [] &#125;, //配置处理小的图片 &#123; test:/\\.(gif|jpg|jpeg|png|svg)$/, use:[ &#123; loader:'url-loader', options:&#123; limit:1024, name:'[name].[ext]' &#125; &#125; ] &#125; ], &#125;,&#125;css预处理器loader引入,顺序按照这种处理器loader在后面，然后`css-loader&gt;style-loader`//添加css预处理器&#123; test:/\\.styl/, use:[ 'style-loader', 'css-loader', 'stylus-loader' ]&#125;, 热更新配置热更新配置是利用一个webpack 的插件来配置，在这里我们由于用的是同一份webpack.config.js，所有我们需要区分好生产环境和开发环境；npm i webpack-dev-server cross-env -D,利用cross-env来设置好使用哪个环境 如果不下载cross-env需要利用set配置好window或者是mac系统12345\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"cross-env NODE_ENV=production webpack --config webpack.config.js\", \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js\"&#125;, 书写的时候将利用配置好的启动项来判断是哪个环境1234567891011121314151617181920212223242526const isDev = process.env.NODE.ENV === 'development'const config = &#123; // ....&#125;if(isDev) &#123; //调试时，使代码映射正常代码 config.devTool = '#cheap-module-eval-source-map' config.devServer = &#123; port:8081, //利用0.0.0.0的好处是可以在任意设备上进行热更新 host:'0.0.0.0', //显示错误 overlay :&#123; errors:true &#125;, //启动该项则只更新代码，而输入的那些页面上的数据不会随着代码的改变而消失 hot: true &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125;module.exports = config","tags":[{"name":"webpack","slug":"webpack","permalink":"https://Alansherlock.github.io/tags/webpack/"}]},{"title":"webpack-todo一","date":"2018-07-23T01:24:04.856Z","path":"2018/07/23/webpack-todo一/","text":"webpack构建可通用的配置文件 搭建开始新建文件夹 webpack-todo 12345678// 进入该文件夹cd webpack-todo// 项目初始化npm init // 下载一些必要的文件，所有的都是用 -D来执行npm i webpack vue-loader vue css-loader -D webpack.config.js书写在根目录新建webpack.config.js,开始配置webpack；由于是使用了webpack4,因此vue-loader需要是以插件的形式来引入到配置环境当中webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path')//webpack4需要引入作为插件使用，区别于2.x,3.x版本const VueLoaderPlugin = require('vue-loader/lib/plugin');module.exports = &#123; mode: \"development\", entry: path.join(__dirname,'src/index.js'), output: &#123; filename: 'bundle.js', path: path.join(__dirname,'dist') &#125;, module: &#123; rules: [ &#123; test:/.css$/, loader:'css-loader' &#125;, &#123; test:/.vue$/, loader:'vue-loader' &#125; ], &#125;, plugins: [ new VueLoaderPlugin() ]&#125;配置webpack打包命令,即npm run build配置package.json的webpack打包命令,即npm run build\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack --config webpack.config.js\"&#125;书写index.jsimport Vue from 'vue'import App from './app.vue'const root = document.createElement('div');document.body.appendChild(root);new Vue(&#123; render:(h)=&gt; h(App)&#125;).$mount(root) app.vue书写新建src做为代码书写目录，开始书写app.vue;由于是以vue结尾的文件，因此我们需要配置vue-loader,来识别该文件由于我们代码里面使用了css-loader,因此需要下载css-loader来解析 12345678910111213141516171819&lt;template&gt; &lt;div id=\"test\"&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return&#123; text:\"abc\" &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; #test &#123; color:red; &#125;&lt;/style&gt;","tags":[{"name":"webpack","slug":"webpack","permalink":"https://Alansherlock.github.io/tags/webpack/"}]},{"title":"vue简单实现响应式","date":"2018-07-23T01:13:22.848Z","path":"2018/07/23/简单实现vue响应式/","text":"看过尤大的vue文档就能知道响应式原理运用的是Object.defineProperty()这个方法；具体的这个方法的解析，可以查看MDN中对Object.defineProperty()的解析， vue简单实现响应式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;简单实现vue响应式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"p\"&gt;&lt;/div&gt; &lt;script&gt; //首先，我们都会围绕着Object.defineProperty，因此这个方法必不可少 // 1. 我们先定义一个函数来接受（data对象，对象的key，对象key值，关于set方法的回调） function defineReactive(obj,key,val,cb,newval) &#123; Object.defineProperty(obj,key,&#123; enumerable:true,//表示可枚举的，如果为false，则在利用for...in...的时候是找不到该属性的 configurable:true,//true该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。 get: ()=&gt;&#123; // console.log(val); return val; &#125;, set: newval =&gt; &#123; //当key被写入新值的时候可以去改变，接着触发我们定义的cd(); if(newval!==val) &#123; val = newval; &#125; cb(); &#125; &#125;) &#125; // 定义一个类名为Vue的 class Vue&#123; constructor(options) &#123; console.log(1); this._data = options.data; observe(this._data,options.render); &#125; &#125; let app = new Vue(&#123; el: '#app', data: &#123; text: 'text', text2: 'text2' &#125;, render()&#123; console.log('this'); &#125; &#125;) function observe(value,cb) &#123; Object.keys(value).forEach((key) =&gt; &#123; // console.log(value); defineReactive(value, key, value[key] , cb)&#125;) &#125; app._data.text2 = 'ceshi'; //更改text2; console.log(app._data.text2); document.querySelector(\".p\").append(app._data.text2+'---'+app._data.text); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://Alansherlock.github.io/tags/vue/"}]},{"title":"nginx代理端口，配置https域名","date":"2018-07-23T00:57:56.558Z","path":"2018/07/23/nginx如何配置/","text":"nginx配置 nginx 安装及配置apt-get update apt-get install nginx sudo service nginx reload,或者有其他的命令能启动就行 开始找NGINX配置文件，有可能在root目录下的usr/etc,或者usr/local,这两个找找，ps -ef | grep nginx 查找文件夹路径， vim nginx.conf,进入，点击i,进入编辑，然后在将以下的文件复制进去，以下需要修改的内容有证书编号，还有端口（如果也和我一样就不需要修改8888，其他详细配置请自行百度或者提issue提问我）123456789101112131415161718192021222324252627282930313233343536373839//配置代理的本地端口地址upstream hello &#123; server 127.0.0.1:8888;&#125;server &#123; listen 80; server_name 67.218.151.13; location / &#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Nginx-proxy true; proxy_pass http://hello; proxy_redirect off; &#125;&#125;//配置 https证书，按照阿里云证书下载指南，建立新的代理地址，将location更改为和上面一样server &#123; listen 443; server_name localhost; ssl on; root html; index index.html index.htm; ssl_certificate cert/21477828393053.pem; ssl_certificate_key cert/21477828393053.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Nginx-proxy true; proxy_pass http://hello; proxy_redirect off; &#125;&#125;","tags":[{"name":"nginx","slug":"nginx","permalink":"https://Alansherlock.github.io/tags/nginx/"}]},{"title":"react小笔记","date":"2018-07-23T00:57:32.102Z","path":"2018/07/23/react小笔记/","text":"对于react初步使用的总结 react 使用小注意 在使用react的时候，开始的时候因为this指向的问题用了bind，然而可以使用e =&gt; {this.tabClick}这种来让this的指向指向定义的那个类，减少代码量 在react中，类似vue指令v-if的写法则是{true?use this: use this},这种来判断； 在循环上，则需要定义好map方法，须记得return 出来当前书写完的这些","tags":[{"name":"react","slug":"react","permalink":"https://Alansherlock.github.io/tags/react/"}]},{"title":"移动端笔记","date":"2018-07-23T00:57:03.253Z","path":"2018/07/23/移动端小知识/","text":"对于移动端小点的总结 移动端笔记 在移动端使用canvas的时候，看的不是画布的大小，而是当前屏幕的大小，因此只要改变当前屏幕的宽高，即可做到让画布适应各个手机； devicePixelRatio，在安卓和iPhone的数值是不一样的，在适应iPhone6/7/8和iPhone6/7/8 plus的时候需要特别的注意这个，在项目中可以不改变这个的数值，根据屏幕的宽度来得知这个是哪种类型的，从而再乘以一个倍数来重新计算当前屏幕的宽高（代码回公司再贴，哈哈哈）； 在移动端布局上，如果遇到弹出键盘挤压当前页面，需要将根部标签的高度设置为当前屏幕的高度,才能在计算的时候不会再次挤压。 在遇到输入完成后键盘收起的时候，也仍需注意第三个的问题，需要计算好屏幕的高度； 由于是移动端，因此在书写一些css的时候，尽可能是用一些缩写的方式，例如背景的可以把所有的属性都写在一个而不是写很多条； 在利用一些css新属性的时候可以查询一下是否兼容性可以 在书写样式的时候，还发现如果当前div利用了背景渐变，则字体颜色是不能渐变的了 在边框上也是，一旦开启渐变，则边框不会有border-radius这个属性生效，做不到圆角 在调试真机的时候，则可以在谷歌下载一个二维码生成插件，利用连着同一WiFi（即网段相同），扫码即可调试 定义在利用flex居中在真机测试有问题，要用传统方式居中（left:50%;transform:tranlate(-50%)，这种） 弹出键盘遇到挤压，在失去焦点的时候再次获取组件的高度","tags":[{"name":"移动端","slug":"移动端","permalink":"https://Alansherlock.github.io/tags/移动端/"}]},{"title":"搭建shadowsocks","date":"2018-07-21T08:43:53.129Z","path":"2018/07/21/vps搭建shadowsock/","text":"先拉取当前镜像，然后直接复制第一条命令 docker pull mritd/shadowsocks docker run -dt --name ss -p 6443:6443 mritd/shadowsocks -s &quot;-s 0.0.0.0 -p 6443 -m aes-256-cfb -k test123 --fast-open&quot; docker ps查看是否运行成功 docker是啥来着开始的时候，我这个小飞机不是自己搭建的，同事说是学不会的，我就很好奇了，这个时候我通过简单的查看和了解是利用了docker，我做前端的一脸懵逼，只能慢慢百度了解；原来，docker是括号里这个介绍（简介：Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。），装完各种奇怪的镜像后，慢慢就懂了，就是个壳，个壳可以往里塞东西；废话不多说，我们现在来了解下关于docker的基本语法；12345678910111213docker images //查看当前镜像列表，就是有多少个镜像装了docker ps // 查看当前正在跑的镜像docker ps -a //包括了未运行的docker rmi [镜像ID] // 删除当前的镜像，有时候会下载错了docker rm [容器ID] // 删除容器，就是ps列表里的了docker run ..docker start //等等请自行百度，太多了，嘻嘻 docker version简单的介绍了一些命令行我们进入主题，其实我们是用这几条来搞定的，哈哈哈，emmmmm; uname -a检查当前系统版本和内核版本（本人版本是16.04） apt-get install -y docker.io利用Linux安装命令，装docker.io,本人在安装的时候出现了英文，没关系，不懂就翻译；（本人自己在安装的时候提示需要先安装两个依赖，但是在朋友阿里的服务器确是不用的，看着提示来装就好了） 等待安装完毕，现在我们使用下面的命令启动 Docker：systemctl start docker 运行系统引导时启用 docker，命令：systemctl enable docker 拉取镜像安装shadowsocks先拉取当前镜像，然后直接复制第一条命令 docker pull mritd/shadowsocks docker run -dt --name ss -p 6443:6443 mritd/shadowsocks -s &quot;-s 0.0.0.0 -p 6443 -m aes-256-cfb -k test123 --fast-open&quot; docker ps查看是否运行成功","tags":[{"name":"other","slug":"other","permalink":"https://Alansherlock.github.io/tags/other/"}]},{"title":"Hello World","date":"2018-07-19T01:40:58.600Z","path":"2018/07/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]