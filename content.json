[{"title":"前端笔记","date":"2018-10-24T07:47:33.306Z","path":"2018/10/24/容易忘记的小知识/","text":"容易忘记的小知识 1234const isLt2M = file.size / 1024 / 1024 &lt; 2if (!isLt2M) &#123; defer.reject('图片必须小于2MB!')&#125;","tags":[{"name":"前端小本","slug":"前端小本","permalink":"https://Alansherlock.github.io/tags/前端小本/"}]},{"title":"前端生成二维码","date":"2018-10-24T07:30:13.501Z","path":"2018/10/24/前端生成二维码/","text":"12345678910111213141516&lt;script src=\"//a.alipayobjects.com/arale-qrcode/3.0.5/index.js\"&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=\"qrPlace\" /&gt;&lt;/body&gt;&lt;script&gt; let el = document.getElementById(\"qrPlace\"); el.appendChild( new AraleQRCode(&#123; render: \"canvas\", size: 150, correctLevel: 1, text: \"后台没给code\" &#125;) ); // \"copy-to-clipboard\": \"^3.0.8\",前端复制插件&lt;/script&gt;","tags":[{"name":"other","slug":"other","permalink":"https://Alansherlock.github.io/tags/other/"}]},{"title":"获取本机IP及所有城市","date":"2018-10-24T07:21:06.474Z","path":"2018/10/24/获取本地IP所有地理位置及所在城市/","text":"12//搜狐获取IP直接放index.html,即可生效，network监听的到&lt;script src=\"//pv.sohu.com/cityjson?ie=utf-8\"&gt;&lt;/script&gt;","tags":[{"name":"移动端","slug":"移动端","permalink":"https://Alansherlock.github.io/tags/移动端/"}]},{"title":"移动端开启调试","date":"2018-10-24T07:18:50.899Z","path":"2018/10/24/移动端调试开启Vconsole/","text":"12345&lt;script src=\"assets/js/vconsole.min.js\"&gt;&lt;/script&gt;&lt;script&gt; new VConsole() &#125;&lt;/script&gt;","tags":[{"name":"移动端","slug":"移动端","permalink":"https://Alansherlock.github.io/tags/移动端/"}]},{"title":"网址校验正则","date":"2018-10-24T06:19:16.409Z","path":"2018/10/24/正则/网址校验正则/","text":"利用这样一个正则，则可以用于校验网址输入是否正确；1let reg = /(http|ftp|https):\\/\\/([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)([\\/\\w \\.-]*)*\\/?$/;","tags":[{"name":"正则","slug":"正则","permalink":"https://Alansherlock.github.io/tags/正则/"}]},{"title":"利用正则校验匹配去掉一些不必要的数字或字母等","date":"2018-10-13T03:05:28.183Z","path":"2018/10/13/正则/正则匹配去除某些不必要的字段/","text":"我们在校验一些密码等东西的时候，经常性需要匹配去掉不该有的数字或字母 123456789/** * 1. 以下这串代码则是可以填写大写字母和数字，但是字母其中需要去掉IOQ这三个，这样我们就需要利用 `?!`这个正则符号来去掉，后面的17大家都清楚，即是长度是需要填写17位*/let reg = /^((?![IOQ])[A-Z0-9])&#123;17&#125;$/if(reg.test(frameNumber)) &#123;&#125;else &#123; console.log(\"车架号VIN输入不正确！\"); return;&#125;","tags":[{"name":"正则","slug":"正则","permalink":"https://Alansherlock.github.io/tags/正则/"}]},{"title":"书写一个手机号校验的正则","date":"2018-10-13T02:56:10.139Z","path":"2018/10/13/正则/校验手机号正则/","text":"利用这样一个正则，则可以用于当前的手机号校验1234567891011let reg = /^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\\d&#123;8&#125;$/;if (phone) &#123;if (reg.test(phone)) &#123;&#125; else &#123; console.log(\"手机号格式有误！\"); return;&#125;&#125; else &#123; console.log(\"请输入手机号！\");return;&#125;","tags":[{"name":"正则","slug":"正则","permalink":"https://Alansherlock.github.io/tags/正则/"}]},{"title":"书写一个身份证校验的正则","date":"2018-10-13T02:51:16.968Z","path":"2018/10/13/正则/身份证验证/","text":"利用这样一个正则，则可以用于当前的身份证校验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /* * 身份证15位编码规则：dddddd yymmdd xx p * dddddd：6位地区编码 * yymmdd: 出生年(两位年)月日，如：910215 * xx: 顺序编码，系统产生，无法确定 * p: 性别，奇数为男，偶数为女 * * 身份证18位编码规则：dddddd yyyymmdd xxx y * dddddd：6位地区编码 * yyyymmdd: 出生年(四位年)月日，如：19910215 * xxx：顺序编码，系统产生，无法确定，奇数为男，偶数为女 * y: 校验码，该位数值可通过前17位计算获得 * * 前17位号码加权因子为 Wi = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ] * 验证位 Y = [ 1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2 ] * 如果验证码恰好是10，为了保证身份证是十八位，那么第十八位将用X来代替 * 校验位计算公式：Y_P = mod( ∑(Ai×Wi),11 ) * i为身份证号码1...17 位; Y_P为校验码Y所在校验码数组位置*/ static validateIdCard(idCard)&#123; //15位和18位身份证号码的正则表达式 var regIdCard=/^(^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$)|(^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])((\\d&#123;4&#125;)|\\d&#123;3&#125;[Xx])$)$/; //如果通过该验证，说明身份证格式正确，但准确性还需计算 if(regIdCard.test(idCard))&#123; if(idCard.length==18)&#123; var idCardWi=new Array( 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ); //将前17位加权因子保存在数组里 var idCardY=new Array( 1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2 ); //这是除以11后，可能产生的11位余数、验证码，也保存成数组 var idCardWiSum=0; //用来保存前17位各自乖以加权因子后的总和 for(var i=0;i&lt;17;i++)&#123; idCardWiSum+=idCard.substring(i,i+1)*idCardWi[i]; &#125; var idCardMod=idCardWiSum%11;//计算出校验码所在数组的位置 var idCardLast=idCard.substring(17);//得到最后一位身份证号码 //如果等于2，则说明校验码是10，身份证号码最后一位应该是X if(idCardMod==2)&#123; if(idCardLast==\"X\"||idCardLast==\"x\")&#123; return &#123;code:0,msg:'验证通过'&#125;; &#125;else&#123; return &#123;code:1,msg:'身份证号码错误！'&#125;; &#125; &#125;else&#123; //用计算出的验证码与最后一位身份证号码匹配，如果一致，说明通过，否则是无效的身份证号码 if(idCardLast==idCardY[idCardMod])&#123; return &#123;code:0,msg:'验证通过'&#125;; &#125;else&#123; return &#123;code:1,msg:'身份证号码错误！'&#125;; &#125; &#125; &#125; &#125;else&#123; return &#123;code:1,msg:'身份证号码格式不正确！'&#125;; &#125; &#125;","tags":[{"name":"正则","slug":"正则","permalink":"https://Alansherlock.github.io/tags/正则/"}]},{"title":"防止页面后退","date":"2018-10-13T02:42:15.587Z","path":"2018/10/13/关于浏览器后退/","text":"利用这串代码来禁止用户点击后退，适用于移动端和PC12345//防止页面后退history.pushState(null, null, document.URL);window.addEventListener('popstate', function () &#123; history.pushState(null, null, document.URL);&#125;); 在离开当前页面的时候，有时候的时候可以将当前这个监听给去掉（补充，当初写这个的场景是在react，离开这个组件的时候需要调用移除监听的方法，才能不影响其他组件，否则会导致其他组件也出现后退不了的情况）","tags":[{"name":"other","slug":"other","permalink":"https://Alansherlock.github.io/tags/other/"}]},{"title":"blob 对象 对于二进制流生成本地地址的使用","date":"2018-09-04T02:03:11.754Z","path":"2018/09/04/关于blob对象的使用/","text":"blob 对象在项目中最常用的则是在前端生成自己的地址，然后用于后端生成的图片或者文件，基本都是二进制格式的，哎，难受； 12345678910111213141516171819202122let blob = new Blob(['后台给的字符串'],&#123;type:'各种需要的格式'&#125;);//例如 image/jpg// 再利用生成地址的APIlet url = window.URL.windowCreateURL();//生成url则可以作用于当前页面//此刻，我需要来串通用的原生代码，因为，像jq封装的dataType:'blob'系不行滴，之前还写过一篇关于vue +axios的博文，也是用到了blob，如果有需要的也可以去看下// react 代码，不过不影响getImgCode() &#123; let that = this; var xhr = new XMLHttpRequest(); xhr.open(\"get\", 'http://servicetest.changan.com.cn/changan-trade-application/api/v1/changan/trade/member/verify/code/image', true); xhr.responseType = \"blob\"; xhr.setRequestHeader(\"openid\", util.getLocalCache('openid')); xhr.onload = function () &#123; if (this.status == 200) &#123; var blob = this.response; that.setState(&#123;imgCode:window.URL.createObjectURL(blob)&#125;); &#125; &#125; xhr.send();&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Alansherlock.github.io/tags/JavaScript/"}]},{"title":"书写一个react组件","date":"2018-08-20T01:34:11.526Z","path":"2018/08/20/react/如何书写一个react组件/","text":"为什么要写react组件，react简单的组件改如何书写？ 在开始书写一个react组件的时候，我们需要了解到react的一些语法，这样才能在书写的过程中，不会有太多的疑问 就了解，当我书写一个react组件的时候，会有一系列的依赖的引入，最简单的莫过于一定要引入react，import React,{Component} from React;这个是在写react哪个组件都要引入的react的依赖，紧接着，你可能还需要一些css也可以通过import的方式来引入到我们的组件当中，有一点需要注意的是，在引入的css样式中，我们需要用一个根标签来包住,防止在书写的时候被其他地方的样式污染； react16的&lt;Fragment&gt;&lt;/Fragment&gt; 书写react，外围有时候需要用一个标签来包住，这个时候我们就可以像引入Component一样引入这个标签包裹在需要一个虚拟的div的地方，从而不会影响页面的布局","tags":[{"name":"react","slug":"react","permalink":"https://Alansherlock.github.io/tags/react/"}]},{"title":"对于vue中$nextTick的理解","date":"2018-07-23T03:05:04.403Z","path":"2018/07/23/vue/vue中nextTick/","text":"input输入限制只能输入小数遇到的问题改了我半天发现是需要利用到$nextTick,翻开了下vue的文档关于$nextTick的解释，如下： 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。 要理解的关键概念是DOM是异步更新的。在Vue中更改值时，更改不会立即呈现给DOM。相反，Vue将DOM更新排队，然后在计时器上更新DOM。通常，这种情况发生得如此之快以至于没有什么区别，但是，有时候，你需要在Vue渲染后更新渲染的DOM，你不能立即在方法中做，因为更新没有发生然而。在那些情况下，你会使用nextTick。来自对于$nextTick的理解 为什么会这样？ 看了染陌大佬的$nextTick解析中有这样一段12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt; &lt;div @click=\"handleClick\"&gt;click&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; number: 0 &#125;; &#125;, methods: &#123; handleClick () &#123; for(let i = 0; i &lt; 1000; i++) &#123; this.number++; &#125; &#125; &#125;&#125;&lt;/script&gt; 当我们按下 click 按钮的时候，number 会被循环增加1000次。 那么按照之前的理解，每次 number 被 +1 的时候，都会触发 number 的 setter 方法，从而根据上面的流程一直跑下来最后修改真实 DOM。那么在这个过程中，DOM 会被更新 1000 次！太可怕了。 Vue.js 肯定不会以如此低效的方法来处理。Vue.js在默认情况下，每次触发某个数据的 setter 方法后，对应的 Watcher 对象其实会被 push 进一个队列 queue 中，在下一个 tick 的时候将这个队列 queue 全部拿出来 run（ Watcher 对象的一个方法，用来触发 patch 操作） 一遍。因为目前浏览器平台并没有实现 nextTick 方法，所以 Vue.js 源码中分别用 Promise、setTimeout、setImmediate 等方式在 microtask（或是task）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。——&lt;–摘自染陌掘金小册–&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://Alansherlock.github.io/tags/vue/"}]},{"title":"webpack加快热更新","date":"2018-07-23T02:55:05.080Z","path":"2018/07/23/webpack/wepack加快热更新/","text":"在项目开始的时候，文件还不会很多，我们都没关心热更新的问题，到了大的时候就编译热更新坐在那里等个好久，我说的好久可能大家的都不一样，哈哈哈；接下来，介绍一些小技巧，往后发现就会继续追更，emmm,嘻嘻 技巧一：利用babel-loader缓存参数12345678910111213module.exports = &#123; module: &#123; noParse: /node_modules\\/(jquey|moment|chart\\.js)/, rules: [ &#123; test: /\\.js$/, loader: 'babel-loader?cacheDirectory', include: [resolve('src'), resolve('test')], exclude:/node_modules/ &#125;, ] &#125;&#125; 项目往后需要编译的文件更多，因此我们从babel-loader下手 由于项目开的时候用的是webpack2.x的版本，但是百度后3.x的这个属性依旧是可以用的，会使之前的热更新加快的其中一个点；忽略编译node_modules,使解析babel-loader再快 技巧二：忽略掉一些大的node_modules里面的模块123456module.exports = &#123; module: &#123; //这里列出一些模块，根据自己项目去除一些编译的文件 noParse: /node_modules\\/(jquey|moment|chart\\.js)/, &#125;&#125;","tags":[{"name":"webpack","slug":"webpack","permalink":"https://Alansherlock.github.io/tags/webpack/"}]},{"title":"vue+axios 上传七牛云图片","date":"2018-07-23T02:43:50.559Z","path":"2018/07/23/七牛云上传图片/","text":"vue+axios 上传七牛云图片 vue+axios 上传七牛云图片图片上传${base}为项目路径QiNiu.upUrl为自己项目的七牛云线上地址Base64.encode(setImgKey())为key值做处理，便于以后删除不是生产服的线上图片具体可以参考七牛云官网12345678910111213141516171819202122232425262728293031323334353637383940414243444546//获取七牛云上传token,此处是后台写的接口获取的token的接口export const getUploadToken = params =&gt; &#123; return axios.get(`$&#123;base&#125;/v1/api/public/getUploadToken`, &#123;params: &#123;...params&#125;&#125;, config);&#125;;//上传图片的接口export const upDetailImg = (params, con) =&gt; &#123; function setImgKey() &#123; const storeId = JSON.parse(sessionStorage.getItem('isLogin')).userId; const date = +new Date() + ''; return storeId + '_' + _env + '_' + md5(storeId + date); &#125; return axios.post(QiNiu.upUrl + '/putb64/-1/key/' + Base64.encode(setImgKey()) + '/', params, con)&#125;,imgUpload(e) &#123; //当前的项目的APPID，来获取七牛上传的token let params = &#123; appId: \"c4805e2dcc\" &#125;; const file = e.target.files;//拿到当前上传的文件数组； for (let i = 0; i &lt; file.length; i++) &#123;//可以对该数组中上传的每一个文件进行文件的大小判断进而做限制 if (file[i].size &gt; 5000000) &#123; return false; &#125; //在执行当前接口获取token的同时new 一个FromData，然后执行需要上传的参数，从而将图片上传； getUploadToken(params).then(res =&gt; &#123; this.img_name.token = res.data.uptoken; var params2 = new FormData(); params2.append(\"file\", file[i]); params2.append(\"token\", res.data.uptoken); params2.append(\"key\", this.setImgKey()); upDetailImgs(params2, &#123;&#125;).then(result =&gt; &#123; const _imgUrl =config.qiniu.baseUrl + result.data.key; this.img_list.push(_imgUrl); &#125;); &#125;); &#125;&#125;,//md5图片上传Key的拼接，获取的是当前的用户Id，以及当前时间，拼接成一个唯一的key值；在以后自己的获取中，如果没有做这个七牛也会随机的生成key，不必拼接；setImgKey() &#123; const storeId = JSON.parse(sessionStorage.getItem(\"isLogin\")).userId; const date = +new Date() + \"\"; return storeId + \"_\" + _env + \"_\" + md5(storeId + date);&#125; 以上就是在项目中用到的图片上传的一个函数； input type = &#39;file&#39;,input的类型为文件类型 accept = &#39;image/png,image/jpeg,image/jpg,image/gif&#39;,限制图片的上传类型， file[i].size，限制图片的上传大小，在设置了多选之后，file为一个数组，因此，需要用for循环对每一个进行判断","tags":[{"name":"vue","slug":"vue","permalink":"https://Alansherlock.github.io/tags/vue/"}]},{"title":"webpack-todo二","date":"2018-07-23T02:23:35.260Z","path":"2018/07/23/webpack/webpack-todo二/","text":"webpack构建可通用的配置文件 简单的静态资源的基本配置配置时候注意转义点.include:[]12345678910111213141516171819202122232425262728293031323334353637383940414243444546const config = &#123; module: &#123; rules: [ &#123; test:/\\.css$/, loader:'css-loader' &#125;, &#123; test:/\\.vue$/, loader:'vue-loader' &#125;, &#123; test:/\\.css$/, use:[ 'style-loader', 'css-loader' ], include: [] &#125;, //配置处理小的图片 &#123; test:/\\.(gif|jpg|jpeg|png|svg)$/, use:[ &#123; loader:'url-loader', options:&#123; limit:1024, name:'[name].[ext]' &#125; &#125; ] &#125; ], &#125;,&#125;css预处理器loader引入,顺序按照这种处理器loader在后面，然后`css-loader&gt;style-loader`//添加css预处理器&#123; test:/\\.styl/, use:[ 'style-loader', 'css-loader', 'stylus-loader' ]&#125;, 热更新配置热更新配置是利用一个webpack 的插件来配置，在这里我们由于用的是同一份webpack.config.js，所有我们需要区分好生产环境和开发环境；npm i webpack-dev-server cross-env -D,利用cross-env来设置好使用哪个环境 如果不下载cross-env需要利用set配置好window或者是mac系统12345\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"cross-env NODE_ENV=production webpack --config webpack.config.js\", \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js\"&#125;, 书写的时候将利用配置好的启动项来判断是哪个环境1234567891011121314151617181920212223242526const isDev = process.env.NODE.ENV === 'development'const config = &#123; // ....&#125;if(isDev) &#123; //调试时，使代码映射正常代码 config.devTool = '#cheap-module-eval-source-map' config.devServer = &#123; port:8081, //利用0.0.0.0的好处是可以在任意设备上进行热更新 host:'0.0.0.0', //显示错误 overlay :&#123; errors:true &#125;, //启动该项则只更新代码，而输入的那些页面上的数据不会随着代码的改变而消失 hot: true &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125;module.exports = config","tags":[{"name":"webpack","slug":"webpack","permalink":"https://Alansherlock.github.io/tags/webpack/"}]},{"title":"webpack-todo一","date":"2018-07-23T01:24:04.856Z","path":"2018/07/23/webpack/webpack-todo一/","text":"webpack构建可通用的配置文件 搭建开始新建文件夹 webpack-todo 12345678// 进入该文件夹cd webpack-todo// 项目初始化npm init // 下载一些必要的文件，所有的都是用 -D来执行npm i webpack vue-loader vue css-loader -D webpack.config.js书写在根目录新建webpack.config.js,开始配置webpack；由于是使用了webpack4,因此vue-loader需要是以插件的形式来引入到配置环境当中webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path')//webpack4需要引入作为插件使用，区别于2.x,3.x版本const VueLoaderPlugin = require('vue-loader/lib/plugin');module.exports = &#123; mode: \"development\", entry: path.join(__dirname,'src/index.js'), output: &#123; filename: 'bundle.js', path: path.join(__dirname,'dist') &#125;, module: &#123; rules: [ &#123; test:/.css$/, loader:'css-loader' &#125;, &#123; test:/.vue$/, loader:'vue-loader' &#125; ], &#125;, plugins: [ new VueLoaderPlugin() ]&#125;配置webpack打包命令,即npm run build配置package.json的webpack打包命令,即npm run build\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack --config webpack.config.js\"&#125;书写index.jsimport Vue from 'vue'import App from './app.vue'const root = document.createElement('div');document.body.appendChild(root);new Vue(&#123; render:(h)=&gt; h(App)&#125;).$mount(root) app.vue书写新建src做为代码书写目录，开始书写app.vue;由于是以vue结尾的文件，因此我们需要配置vue-loader,来识别该文件由于我们代码里面使用了css-loader,因此需要下载css-loader来解析 12345678910111213141516171819&lt;template&gt; &lt;div id=\"test\"&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return&#123; text:\"abc\" &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; #test &#123; color:red; &#125;&lt;/style&gt;","tags":[{"name":"webpack","slug":"webpack","permalink":"https://Alansherlock.github.io/tags/webpack/"}]},{"title":"vue简单实现响应式","date":"2018-07-23T01:13:22.848Z","path":"2018/07/23/vue/简单实现vue响应式/","text":"看过尤大的vue文档就能知道响应式原理运用的是Object.defineProperty()这个方法；具体的这个方法的解析，可以查看MDN中对Object.defineProperty()的解析， vue简单实现响应式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;简单实现vue响应式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"p\"&gt;&lt;/div&gt; &lt;script&gt; //首先，我们都会围绕着Object.defineProperty，因此这个方法必不可少 // 1. 我们先定义一个函数来接受（data对象，对象的key，对象key值，关于set方法的回调） function defineReactive(obj,key,val,cb,newval) &#123; Object.defineProperty(obj,key,&#123; enumerable:true,//表示可枚举的，如果为false，则在利用for...in...的时候是找不到该属性的 configurable:true,//true该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。 get: ()=&gt;&#123; // console.log(val); return val; &#125;, set: newval =&gt; &#123; //当key被写入新值的时候可以去改变，接着触发我们定义的cd(); if(newval!==val) &#123; val = newval; &#125; cb(); &#125; &#125;) &#125; // 定义一个类名为Vue的 class Vue&#123; constructor(options) &#123; console.log(1); this._data = options.data; observe(this._data,options.render); &#125; &#125; let app = new Vue(&#123; el: '#app', data: &#123; text: 'text', text2: 'text2' &#125;, render()&#123; console.log('this'); &#125; &#125;) function observe(value,cb) &#123; Object.keys(value).forEach((key) =&gt; &#123; // console.log(value); defineReactive(value, key, value[key] , cb)&#125;) &#125; app._data.text2 = 'ceshi'; //更改text2; console.log(app._data.text2); document.querySelector(\".p\").append(app._data.text2+'---'+app._data.text); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://Alansherlock.github.io/tags/vue/"}]},{"title":"nginx代理端口，配置https域名","date":"2018-07-23T00:57:56.558Z","path":"2018/07/23/nginx如何配置/","text":"nginx配置 nginx 安装及配置apt-get update apt-get install nginx sudo service nginx reload,或者有其他的命令能启动就行 开始找NGINX配置文件，有可能在root目录下的usr/etc,或者usr/local,这两个找找，ps -ef | grep nginx 查找文件夹路径， vim nginx.conf,进入，点击i,进入编辑，然后在将以下的文件复制进去，以下需要修改的内容有证书编号，还有端口（如果也和我一样就不需要修改8888，其他详细配置请自行百度或者提issue提问我）123456789101112131415161718192021222324252627282930313233343536373839//配置代理的本地端口地址upstream hello &#123; server 127.0.0.1:8888;&#125;server &#123; listen 80; server_name 67.218.151.13; location / &#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Nginx-proxy true; proxy_pass http://hello; proxy_redirect off; &#125;&#125;//配置 https证书，按照阿里云证书下载指南，建立新的代理地址，将location更改为和上面一样server &#123; listen 443; server_name localhost; ssl on; root html; index index.html index.htm; ssl_certificate cert/21477828393053.pem; ssl_certificate_key cert/21477828393053.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Nginx-proxy true; proxy_pass http://hello; proxy_redirect off; &#125;&#125;","tags":[{"name":"nginx","slug":"nginx","permalink":"https://Alansherlock.github.io/tags/nginx/"}]},{"title":"react使用笔记","date":"2018-07-23T00:57:32.102Z","path":"2018/07/23/react/react小笔记/","text":"对于react初步使用的总结 react 使用react 中this指向问题在使用react的时候，开始的时候因为this指向的问题用了bind，然而可以使用e =&gt; {this.tabClick}这种来让this的指向指向定义的那个类，减少代码量 react中判断语句一般采用三元表达式来作判断在react中，类似vue指令v-if的写法则是{true?use this: use this},这种来判断； react 中循环的写法在循环上，则需要定义好map方法，须记得return 出来当前书写完的这些 获取地址栏参数1this.props.location.query;// query则可以拿到一个对象，这个对象包含了传递的参数 【场景：mobx+react】 react 导入HTML123&lt;div className='description'&gt; &lt;p dangerouslySetInnerHTML=&#123;&#123; __html: activityDetail.content &#125;&#125; /&gt;&lt;/div&gt; react 虚拟标签(本人叫法，有点类似Vue里面经常使用的template标签)1234&#123;x.imageUrl ?&lt;Fragment&gt; &lt;img src=&#123;x.imageUrl&#125; style=&#123;&#123; width: '90%' &#125;&#125; alt=\"图片查看\" /&gt;&lt;br /&gt;&lt;/Fragment&gt; : null&#125;","tags":[{"name":"react","slug":"react","permalink":"https://Alansherlock.github.io/tags/react/"}]},{"title":"移动端笔记","date":"2018-07-23T00:57:03.253Z","path":"2018/07/23/移动端小知识/","text":"对于移动端小点的总结 移动端笔记 在移动端使用canvas的时候，看的不是画布的大小，而是当前屏幕的大小，因此只要改变当前屏幕的宽高，即可做到让画布适应各个手机； devicePixelRatio，在安卓和iPhone的数值是不一样的，在适应iPhone6/7/8和iPhone6/7/8 plus的时候需要特别的注意这个，在项目中可以不改变这个的数值，根据屏幕的宽度来得知这个是哪种类型的，从而再乘以一个倍数来重新计算当前屏幕的宽高（代码回公司再贴，哈哈哈）； 在移动端布局上，如果遇到弹出键盘挤压当前页面，需要将根部标签的高度设置为当前屏幕的高度,才能在计算的时候不会再次挤压。 在遇到输入完成后键盘收起的时候，也仍需注意第三个的问题，需要计算好屏幕的高度； 由于是移动端，因此在书写一些css的时候，尽可能是用一些缩写的方式，例如背景的可以把所有的属性都写在一个而不是写很多条； 在利用一些css新属性的时候可以查询一下是否兼容性可以 在书写样式的时候，还发现如果当前div利用了背景渐变，则字体颜色是不能渐变的了 在边框上也是，一旦开启渐变，则边框不会有border-radius这个属性生效，做不到圆角 在调试真机的时候，则可以在谷歌下载一个二维码生成插件，利用连着同一WiFi（即网段相同），扫码即可调试 定义在利用flex居中在真机测试有问题，要用传统方式居中（left:50%;transform:tranlate(-50%)，这种） 弹出键盘遇到挤压，在失去焦点的时候再次获取组件的高度 IOS滑动滚动不流畅时候，不应该使用over-flow:scroll;而是应该用touch-scroll(记得是这个)；","tags":[{"name":"移动端","slug":"移动端","permalink":"https://Alansherlock.github.io/tags/移动端/"}]},{"title":"搭建shadowsocks","date":"2018-07-21T08:43:53.129Z","path":"2018/07/21/vps搭建shadowsock/","text":"先拉取当前镜像，然后直接复制第一条命令 docker pull mritd/shadowsocks docker run -dt --name ss -p 6443:6443 mritd/shadowsocks -s &quot;-s 0.0.0.0 -p 6443 -m aes-256-cfb -k test123 --fast-open&quot; docker ps查看是否运行成功 docker是啥来着开始的时候，我这个小飞机不是自己搭建的，同事说是学不会的，我就很好奇了，这个时候我通过简单的查看和了解是利用了docker，我做前端的一脸懵逼，只能慢慢百度了解；原来，docker是括号里这个介绍（简介：Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。），装完各种奇怪的镜像后，慢慢就懂了，就是个壳，个壳可以往里塞东西；废话不多说，我们现在来了解下关于docker的基本语法；12345678910111213docker images //查看当前镜像列表，就是有多少个镜像装了docker ps // 查看当前正在跑的镜像docker ps -a //包括了未运行的docker rmi [镜像ID] // 删除当前的镜像，有时候会下载错了docker rm [容器ID] // 删除容器，就是ps列表里的了docker run ..docker start //等等请自行百度，太多了，嘻嘻 docker version简单的介绍了一些命令行我们进入主题，其实我们是用这几条来搞定的，哈哈哈，emmmmm; uname -a检查当前系统版本和内核版本（本人版本是16.04） apt-get install -y docker.io利用Linux安装命令，装docker.io,本人在安装的时候出现了英文，没关系，不懂就翻译；（本人自己在安装的时候提示需要先安装两个依赖，但是在朋友阿里的服务器确是不用的，看着提示来装就好了） 等待安装完毕，现在我们使用下面的命令启动 Docker：systemctl start docker 运行系统引导时启用 docker，命令：systemctl enable docker 拉取镜像安装shadowsocks先拉取当前镜像，然后直接复制第一条命令 docker pull mritd/shadowsocks docker run -dt --name ss -p 6443:6443 mritd/shadowsocks -s &quot;-s 0.0.0.0 -p 6443 -m aes-256-cfb -k test123 --fast-open&quot; docker ps查看是否运行成功","tags":[{"name":"other","slug":"other","permalink":"https://Alansherlock.github.io/tags/other/"}]},{"title":"Hello World","date":"2018-07-19T01:40:58.600Z","path":"2018/07/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]