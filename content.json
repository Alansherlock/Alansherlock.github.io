[{"title":"github被屏蔽后如何提交代码","date":"2019-04-15T01:05:48.672Z","path":"2019/04/15/其他/github被屏蔽后如何提交代码/","text":"往github上提交代码一直提示错误信息“fatal: unable to access ‘https://github.com/xxxx.git/&#39;: Failed to connect to github.com port 443: Connection refused“，被墙了，需要使用代理。 github代理配置12345// 1080为我自己VPN本地代理启用的端口号，可替代为自己VPN的端口号// git config --global http.proxy \"localhost:1080\"git config --global http.proxy 'socks5://127.0.0.1:1080'git config --global https.proxy 'socks5://127.0.0.1:1080'// 公司的网关还是牛逼 执行完楼上的命令后，即可git push,心情愉悦！！！","tags":[{"name":"github","slug":"github","permalink":"https://Alansherlock.github.io/tags/github/"}]},{"title":"git修改分支名","date":"2019-04-15T01:05:48.672Z","path":"2019/04/15/其他/git修改分支名/","text":"git branch -m old_branch new_branch # Rename branch locallygit push origin :old_branch # Delete the old branchgit push –set-upstream origin new_branch # Push the new branch, set local branch to track the new remote","tags":[]},{"title":"一道数组面试题","date":"2019-01-16T09:07:09.218Z","path":"2019/01/16/js/一道js数组面试题/","text":"我们来爬一爬123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;// oldlet oldlist = [ &#123;id:1,list:[1,2,3]&#125;, &#123;id:2,list:[4,5]&#125;, &#123;id:1,list:[4,5]&#125;];let keys = Array.from(new Set(oldlist.map(item =&gt; item.id)))let newlist= keys.map(key=&gt;&#123; var temp = new Array(); oldlist.filter(item=&gt;item.id==key).reduce((pre,cur)=&gt;&#123; temp = temp.concat(cur.list) &#125;,0) return &#123;id:key,list:temp&#125;&#125;)console.log(JSON.stringify(newlist));function mapObj(list) &#123; var obj = &#123;&#125;; for (let item of list) &#123; console.log(!obj[item.id]); if (!obj[item.id]) &#123; console.log(item.id); obj[item.id] = item.list; &#125; else &#123; obj[item.id] = obj[item.id].concat(item.list); console.log(obj[item.id]); &#125; &#125; return Object.keys(obj).map(key =&gt; &#123; return &#123; id: key, list: obj[key] &#125; &#125;);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Alansherlock.github.io/tags/JavaScript/"}]},{"title":"爬取酷狗付费歌曲","date":"2019-01-15T09:57:40.905Z","path":"2019/01/15/Python/爬取酷狗付费歌曲/","text":"我们来爬一爬在终端运行py 文件名12345678910111213141516171819202122232425262728293031import requestsimport jsonimport redef get_song(x): url = \"http://songsearch.kugou.com/song_search_v2?callback=jQuery112407470964083509348_1534929985284&amp;keyword=&#123;&#125;&amp;\" \\ \"page=1&amp;pagesize=30&amp;userid=-1&amp;clientver=&amp;platform=WebFilter&amp;tag=em&amp;filter=2&amp;iscorrection=1&amp;privilege_filte\" \\ \"r=0&amp;_=1534929985286\".format(x) res = requests.get(url).text js = json.loads(res[res.index('(') + 1:-2]) data = js['data']['lists'] for i in range(10): print(str(i + 1) + \"&gt;&gt;&gt;\" + str(data[i]['FileName']).replace('&lt;em&gt;', '').replace('&lt;/em&gt;', '')) number = int(input(\"\\n请输入要下载的歌曲序号（输入-1退出程序）: \")) if number == -1: exit() else: name = str(data[number - 1]['FileName']).replace('&lt;em&gt;', '').replace('&lt;/em&gt;', '') fhash = re.findall('\"FileHash\":\"(.*?)\"', res)[number - 1] hash_url = \"http://www.kugou.com/yy/index.php?r=play/getdata&amp;hash=\" + fhash hash_content = requests.get(hash_url) play_url = ''.join(re.findall('\"play_url\":\"(.*?)\"', hash_content.text)) real_download_url = play_url.replace(\"\\\\\", \"\") with open(name + \".mp3\", \"wb\")as fp: fp.write(requests.get(real_download_url).content) print(\"歌曲已下载完成！\")if __name__ == '__main__': x = input(\"请输入歌名：\") get_song(x)","tags":[{"name":"Python","slug":"Python","permalink":"https://Alansherlock.github.io/tags/Python/"}]},{"title":"书写一个身份证校验的正则","date":"2019-01-15T09:44:54.786Z","path":"2019/01/15/正则/身份证验证/","text":"利用这样一个正则，则可以用于当前的身份证校验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /* * 身份证15位编码规则：dddddd yymmdd xx p * dddddd：6位地区编码 * yymmdd: 出生年(两位年)月日，如：910215 * xx: 顺序编码，系统产生，无法确定 * p: 性别，奇数为男，偶数为女 * * 身份证18位编码规则：dddddd yyyymmdd xxx y * dddddd：6位地区编码 * yyyymmdd: 出生年(四位年)月日，如：19910215 * xxx：顺序编码，系统产生，无法确定，奇数为男，偶数为女 * y: 校验码，该位数值可通过前17位计算获得 * * 前17位号码加权因子为 Wi = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ] * 验证位 Y = [ 1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2 ] * 如果验证码恰好是10，为了保证身份证是十八位，那么第十八位将用X来代替 * 校验位计算公式：Y_P = mod( ∑(Ai×Wi),11 ) * i为身份证号码1...17 位; Y_P为校验码Y所在校验码数组位置*/ static validateIdCard(idCard)&#123; //15位和18位身份证号码的正则表达式 var regIdCard=/^(^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$)|(^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])((\\d&#123;4&#125;)|\\d&#123;3&#125;[Xx])$)$/; //如果通过该验证，说明身份证格式正确，但准确性还需计算 if(regIdCard.test(idCard))&#123; if(idCard.length==18)&#123; var idCardWi=new Array( 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ); //将前17位加权因子保存在数组里 var idCardY=new Array( 1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2 ); //这是除以11后，可能产生的11位余数、验证码，也保存成数组 var idCardWiSum=0; //用来保存前17位各自乖以加权因子后的总和 for(var i=0;i&lt;17;i++)&#123; idCardWiSum+=idCard.substring(i,i+1)*idCardWi[i]; &#125; var idCardMod=idCardWiSum%11;//计算出校验码所在数组的位置 var idCardLast=idCard.substring(17);//得到最后一位身份证号码 //如果等于2，则说明校验码是10，身份证号码最后一位应该是X if(idCardMod==2)&#123; if(idCardLast==\"X\"||idCardLast==\"x\")&#123; return &#123;code:0,msg:'验证通过'&#125;; &#125;else&#123; return &#123;code:1,msg:'身份证号码错误！'&#125;; &#125; &#125;else&#123; //用计算出的验证码与最后一位身份证号码匹配，如果一致，说明通过，否则是无效的身份证号码 if(idCardLast==idCardY[idCardMod])&#123; return &#123;code:0,msg:'验证通过'&#125;; &#125;else&#123; return &#123;code:1,msg:'身份证号码错误！'&#125;; &#125; &#125; &#125; &#125;else&#123; return &#123;code:1,msg:'身份证号码格式不正确！'&#125;; &#125; &#125;","tags":[{"name":"正则","slug":"正则","permalink":"https://Alansherlock.github.io/tags/正则/"}]},{"title":"网址校验正则","date":"2019-01-15T09:44:54.785Z","path":"2019/01/15/正则/网址校验正则/","text":"利用这样一个正则，则可以用于校验网址输入是否正确；1let reg = /(http|ftp|https):\\/\\/([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)([\\/\\w \\.-]*)*\\/?$/;","tags":[{"name":"正则","slug":"正则","permalink":"https://Alansherlock.github.io/tags/正则/"}]},{"title":"利用正则校验匹配去掉一些不必要的数字或字母等","date":"2019-01-15T09:44:54.785Z","path":"2019/01/15/正则/正则匹配去除某些不必要的字段/","text":"我们在校验一些密码等东西的时候，经常性需要匹配去掉不该有的数字或字母 123456789/** * 1. 以下这串代码则是可以填写大写字母和数字，但是字母其中需要去掉IOQ这三个，这样我们就需要利用 `?!`这个正则符号来去掉，后面的17大家都清楚，即是长度是需要填写17位*/let reg = /^((?![IOQ])[A-Z0-9])&#123;17&#125;$/if(reg.test(frameNumber)) &#123;&#125;else &#123; console.log(\"车架号VIN输入不正确！\"); return;&#125;","tags":[{"name":"正则","slug":"正则","permalink":"https://Alansherlock.github.io/tags/正则/"}]},{"title":"书写一个手机号校验的正则","date":"2019-01-15T09:44:54.785Z","path":"2019/01/15/正则/校验手机号正则/","text":"利用这样一个正则，则可以用于当前的手机号校验1234567891011let reg = /^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\\d&#123;8&#125;$/;if (phone) &#123;if (reg.test(phone)) &#123;&#125; else &#123; console.log(\"手机号格式有误！\"); return;&#125;&#125; else &#123; console.log(\"请输入手机号！\");return;&#125;","tags":[{"name":"正则","slug":"正则","permalink":"https://Alansherlock.github.io/tags/正则/"}]},{"title":"微信分享","date":"2019-01-15T09:44:54.784Z","path":"2019/01/15/微信/微信分享/","text":"微信授权在这一步上项目中是直接调取了后台书写好的接口，在这一步也很重要，为后面分享埋下伏笔12//http://servicetest.changan.com.cn/changan-trade-application/api/v1/weixin/redirect?url=http://servicetest.changan.com.cn/changan-b2c-web-h5/// 在分享前先让用户进入当前页面的时候就必须获取授权，否则根本拿取不到openId,也进行不到下一步，通过接口也可以看出，url必须是当前页面的 获取微信config接口这个接口也是由后端先接入微信 1234567891011// http://servicetest.changan.com.cn/changan-trade-application/api/v1/weixin/config?url=http%3A%2F%2F192.168.111.120%3A8082%2F&amp;openid=2.168.111.120%3A8082%2F// 从楼上也可以判断出来需要传url和openId来给到后端，而openId则是由楼上的授权接口先获取到&#123; \"signature\":\"a6e77a6b2f0c88cdd3554d864c09f09fcf5efa7b\", \"appId\":\"wxe427052c635210e8\", \"jsapi_ticket\":\"gdzxN2g622vVfv3lEXnBsu4pFZhQIyBUn_7uqUP9-sD7BJOGfsbsyJfsn3rv-ulEWgm3QR1bglPYQ0iwO4WWSg\", // 实际场景中url则会是线上地址 \"url\":\"http://192.168.111.120:8082/\", \"nonceStr\":\"3135ec04-6f49-46bf-a21b-2b58055b9b44\", \"timestamp\":\"1544582200\"&#125; 微信config (wx.config)进行了楼上两个步骤后，我们开始开始进行微信API的配置，在2018这个分水岭，微信分享做了处理，分享接口有两个无法获取是否分享成功（失败监听不了的意思），但是还是能够监听success接口的回调，这两个 onMenuShareTimeline`onMenuShareAppMessage; 还有两个新的APIupdateAppMessageShareDataupdateTimelineShareData`,这两个在实践中还是监听不到success，建议先用旧的，也可能是我太菜了哎楼下的data则上楼下config接口回来并且填入的数据，一环扣一环12345678910111213wx.config(&#123; debug: debug, appId: data.appId, timestamp: data.timestamp, nonceStr: data.nonceStr, signature: data.signature, jsApiList: [ 'onMenuShareTimeline', // 分享到朋友圈接口 'onMenuShareAppMessage', // 分享到朋友接口 'updateAppMessageShareData', //1.4 分享到朋友 'updateTimelineShareData', //1.4分享到朋友圈 ]&#125;); 微信分享在这一步的encodeURIComponent则是因为我用的react框架中的hash模式，带了 #号，需要为后面的参数做转码，不然分享后数据会因为微信的分享机制而被截取掉（之前遇到的情况是安卓机会截取而IOS不会）；在这一步上则是在页面进入的初始上就立马调用，微信文档上有句文档叫可能分享的情况下提前调用’ sendData 里面有个Config.authURL,这个玩意则是后端给的微信授权后重定向的接口路径，是第一步骤上的url，防止新用户进入到新页面没授权拿取不到openId,直接调用的骚操作1234567891011121314151617181920212223//进行data的数据配置let sendData = &#123; title: '长安汽车尊享服务-活动问卷详情', // 分享标题 desc: '长安汽车尊享服务活动问卷详情', // 分享描述 link: `$&#123;Config.authURL&#125;$&#123;encodeURIComponent('#' + '/questionnaire?' + 'id=' + query.id + '&amp;status=' + `$&#123;query.status ? query.status : ''&#125;` + \"&amp;mId=\" + mld + \"&amp;oId=\" + old)&#125;`, imgUrl: 'http://servicetest.changan.com.cn/changan-mgmt-application/img/2018-11-19/1542596562162.jpg', // 分享图标 success: function (res) &#123; // 设置成功 console.log('Set Shareinfo ok', res) &#125;&#125;;wx.ready(function () &#123; console.warn(sendData, 'sendData'); wx.updateAppMessageShareData(sendData); wx.updateTimelineShareData(sendData); wx.onMenuShareTimeline(sendData); wx.onMenuShareAppMessage(sendData); console.log('WXSDK is Ready!!');&#125;)&#125;).fail(e =&gt; &#123;console.error(\"接口出错！\" + e);&#125;);","tags":[]},{"title":"获取本机IP及所有城市","date":"2019-01-15T09:44:54.784Z","path":"2019/01/15/其他/获取本地IP所有地理位置及所在城市/","text":"12//搜狐获取IP直接放index.html,即可生效，network监听的到&lt;script src=\"//pv.sohu.com/cityjson?ie=utf-8\"&gt;&lt;/script&gt;","tags":[{"name":"移动端","slug":"移动端","permalink":"https://Alansherlock.github.io/tags/移动端/"}]},{"title":"移动端开启调试","date":"2019-01-15T09:44:54.784Z","path":"2019/01/15/其他/移动端调试开启Vconsole/","text":"12345&lt;script src=\"assets/js/vconsole.min.js\"&gt;&lt;/script&gt;&lt;script&gt; new VConsole() &#125;&lt;/script&gt;","tags":[{"name":"移动端","slug":"移动端","permalink":"https://Alansherlock.github.io/tags/移动端/"}]},{"title":"移动端解决键盘收起留白","date":"2019-01-15T09:44:54.783Z","path":"2019/01/15/其他/移动端解决键盘收起留白/","text":"在失去焦点的时候将高度置为window.innerHeight;1234//失焦的时候去调用这个方法，在react上的写法，其他的也是类似的操作 onBlur() &#123; this.setState(&#123;height:window.innerHeight&#125;);&#125; 另外一种方式，设置滚动window.scrollTo(x,y);滚动到相对应的位置，不过效果不是很友好1234567891011// 贴上react上一段blur的代码，楼下是判断IOS和安卓的代码，从而解决项目中微信6.7.4出现的键盘留白问题onBlurIos() &#123; let &#123; activityDetail &#125; = this.props; var u = navigator.userAgent, app = navigator.appVersion; var isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端 if (isiOS) &#123; window.setTimeout(function () &#123; window.scrollTo(0, activityDetail.scrollTop + 140); &#125;, 30); &#125;&#125;","tags":[{"name":"移动端","slug":"移动端","permalink":"https://Alansherlock.github.io/tags/移动端/"}]},{"title":"移动端笔记","date":"2019-01-15T09:44:54.783Z","path":"2019/01/15/其他/移动端小知识/","text":"对于移动端小点的总结 移动端笔记 在移动端使用canvas的时候，看的不是画布的大小，而是当前屏幕的大小，因此只要改变当前屏幕的宽高，即可做到让画布适应各个手机； devicePixelRatio，在安卓和iPhone的数值是不一样的，在适应iPhone6/7/8和iPhone6/7/8 plus的时候需要特别的注意这个，在项目中可以不改变这个的数值，根据屏幕的宽度来得知这个是哪种类型的，从而再乘以一个倍数来重新计算当前屏幕的宽高（代码回公司再贴，哈哈哈）； 在移动端布局上，如果遇到弹出键盘挤压当前页面，需要将根部标签的高度设置为当前屏幕的高度,才能在计算的时候不会再次挤压。 在遇到输入完成后键盘收起的时候，也仍需注意第三个的问题，需要计算好屏幕的高度； 由于是移动端，因此在书写一些css的时候，尽可能是用一些缩写的方式，例如背景的可以把所有的属性都写在一个而不是写很多条； 在利用一些css新属性的时候可以查询一下是否兼容性可以 在书写样式的时候，还发现如果当前div利用了背景渐变，则字体颜色是不能渐变的了 在边框上也是，一旦开启渐变，则边框不会有border-radius这个属性生效，做不到圆角 在调试真机的时候，则可以在谷歌下载一个二维码生成插件，利用连着同一WiFi（即网段相同），扫码即可调试 定义在利用flex居中在真机测试有问题，要用传统方式居中（left:50%;transform:tranlate(-50%)，这种） 弹出键盘遇到挤压，在失去焦点的时候再次获取组件的高度 IOS滑动滚动不流畅时候，不应该使用over-flow:scroll;而是应该用touch-scroll(记得是这个)；","tags":[{"name":"移动端","slug":"移动端","permalink":"https://Alansherlock.github.io/tags/移动端/"}]},{"title":"前端笔记","date":"2019-01-15T09:44:54.783Z","path":"2019/01/15/其他/容易忘记的小知识/","text":"容易忘记的小知识 1234const isLt2M = file.size / 1024 / 1024 &lt; 2if (!isLt2M) &#123; defer.reject('图片必须小于2MB!')&#125;","tags":[{"name":"前端小本","slug":"前端小本","permalink":"https://Alansherlock.github.io/tags/前端小本/"}]},{"title":"防止页面后退","date":"2019-01-15T09:44:54.782Z","path":"2019/01/15/其他/关于浏览器后退/","text":"利用这串代码来禁止用户点击后退，适用于移动端和PC12345//防止页面后退history.pushState(null, null, document.URL);window.addEventListener('popstate', function () &#123; history.pushState(null, null, document.URL);&#125;); 在离开当前页面的时候，有时候的时候可以将当前这个监听给去掉（补充，当初写这个的场景是在react，离开这个组件的时候需要调用移除监听的方法，才能不影响其他组件，否则会导致其他组件也出现后退不了的情况）","tags":[{"name":"other","slug":"other","permalink":"https://Alansherlock.github.io/tags/other/"}]},{"title":"解决多台电脑使用hexo的问题","date":"2019-01-15T09:44:54.782Z","path":"2019/01/15/其他/多台电脑使用hexo/","text":"在使用hexo的过程中，我开始是在上家公司写的东西全部提交到了hexo，以为就好了，结果换新公司从新电脑拉下来后不知道怎么搞了，原先的那些东西都没了，为了解决这个，我在度娘上找到了方案，写在这里，做下记录 解决方案 在线上的git仓库上新建一个分支，例如名字为hexo; 在当前的仓库的Settings &gt; Branchs 更新hexo分支为默认分支 更新完后我们将代码都拉取下来，拉取的是hexo分支了现在，此时我们看到的东西是长这样的 此时，我们开始下一步操作，我们将本地之前hexo搞的那整一份全部拷贝进入我们的这个hexo（谨记，将themes里面的.git先删除），接下来我们看到的文件夹是这样的 此时我们可以运行一些命令把这一份代码提交到GitHub了，git add . git commit -m &#39;some description&#39; git push,这样到线上看到的就已经把整一个静态资源的也push上去了，在线上看到如下， 此时，我们已经算完成了，接下来我们再到另外一台电脑来试试， 搞好ssh,然后克隆到新电脑，紧接着我们npm i,安装一些依赖，书写完文件后，执行hexo d -g指令（在此之前，有时可能需要执行hexo clean），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！ 有问题可以联系我邮箱 Alansherlock@163,com,或者留言评论！","tags":[{"name":"hexo","slug":"hexo","permalink":"https://Alansherlock.github.io/tags/hexo/"}]},{"title":"前端生成二维码","date":"2019-01-15T09:44:54.782Z","path":"2019/01/15/其他/前端生成二维码/","text":"12345678910111213141516&lt;script src=\"//a.alipayobjects.com/arale-qrcode/3.0.5/index.js\"&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=\"qrPlace\" /&gt;&lt;/body&gt;&lt;script&gt; let el = document.getElementById(\"qrPlace\"); el.appendChild( new AraleQRCode(&#123; render: \"canvas\", size: 150, correctLevel: 1, text: \"后台没给code\" &#125;) ); // \"copy-to-clipboard\": \"^3.0.8\",前端复制插件&lt;/script&gt;","tags":[{"name":"other","slug":"other","permalink":"https://Alansherlock.github.io/tags/other/"}]},{"title":"blob 对象 对于二进制流生成本地地址的使用","date":"2019-01-15T09:44:54.782Z","path":"2019/01/15/其他/关于blob对象的使用/","text":"blob 对象在项目中最常用的则是在前端生成自己的地址，然后用于后端生成的图片或者文件，基本都是二进制格式的，哎，难受； 12345678910111213141516171819202122let blob = new Blob(['后台给的字符串'],&#123;type:'各种需要的格式'&#125;);//例如 image/jpg// 再利用生成地址的APIlet url = window.URL.windowCreateURL();//生成url则可以作用于当前页面//此刻，我需要来串通用的原生代码，因为，像jq封装的dataType:'blob'系不行滴，之前还写过一篇关于vue +axios的博文，也是用到了blob，如果有需要的也可以去看下// react 代码，不过不影响getImgCode() &#123; let that = this; var xhr = new XMLHttpRequest(); xhr.open(\"get\", 'http://servicetest.changan.com.cn/changan-trade-application/api/v1/changan/trade/member/verify/code/image', true); xhr.responseType = \"blob\"; xhr.setRequestHeader(\"openid\", util.getLocalCache('openid')); xhr.onload = function () &#123; if (this.status == 200) &#123; var blob = this.response; that.setState(&#123;imgCode:window.URL.createObjectURL(blob)&#125;); &#125; &#125; xhr.send();&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Alansherlock.github.io/tags/JavaScript/"}]},{"title":"vue+axios 上传七牛云图片","date":"2019-01-15T09:44:54.781Z","path":"2019/01/15/其他/七牛云上传图片/","text":"vue+axios 上传七牛云图片 vue+axios 上传七牛云图片图片上传${base}为项目路径QiNiu.upUrl为自己项目的七牛云线上地址Base64.encode(setImgKey())为key值做处理，便于以后删除不是生产服的线上图片具体可以参考七牛云官网12345678910111213141516171819202122232425262728293031323334353637383940414243444546//获取七牛云上传token,此处是后台写的接口获取的token的接口export const getUploadToken = params =&gt; &#123; return axios.get(`$&#123;base&#125;/v1/api/public/getUploadToken`, &#123;params: &#123;...params&#125;&#125;, config);&#125;;//上传图片的接口export const upDetailImg = (params, con) =&gt; &#123; function setImgKey() &#123; const storeId = JSON.parse(sessionStorage.getItem('isLogin')).userId; const date = +new Date() + ''; return storeId + '_' + _env + '_' + md5(storeId + date); &#125; return axios.post(QiNiu.upUrl + '/putb64/-1/key/' + Base64.encode(setImgKey()) + '/', params, con)&#125;,imgUpload(e) &#123; //当前的项目的APPID，来获取七牛上传的token let params = &#123; appId: \"c4805e2dcc\" &#125;; const file = e.target.files;//拿到当前上传的文件数组； for (let i = 0; i &lt; file.length; i++) &#123;//可以对该数组中上传的每一个文件进行文件的大小判断进而做限制 if (file[i].size &gt; 5000000) &#123; return false; &#125; //在执行当前接口获取token的同时new 一个FromData，然后执行需要上传的参数，从而将图片上传； getUploadToken(params).then(res =&gt; &#123; this.img_name.token = res.data.uptoken; var params2 = new FormData(); params2.append(\"file\", file[i]); params2.append(\"token\", res.data.uptoken); params2.append(\"key\", this.setImgKey()); upDetailImgs(params2, &#123;&#125;).then(result =&gt; &#123; const _imgUrl =config.qiniu.baseUrl + result.data.key; this.img_list.push(_imgUrl); &#125;); &#125;); &#125;&#125;,//md5图片上传Key的拼接，获取的是当前的用户Id，以及当前时间，拼接成一个唯一的key值；在以后自己的获取中，如果没有做这个七牛也会随机的生成key，不必拼接；setImgKey() &#123; const storeId = JSON.parse(sessionStorage.getItem(\"isLogin\")).userId; const date = +new Date() + \"\"; return storeId + \"_\" + _env + \"_\" + md5(storeId + date);&#125; 以上就是在项目中用到的图片上传的一个函数； input type = &#39;file&#39;,input的类型为文件类型 accept = &#39;image/png,image/jpeg,image/jpg,image/gif&#39;,限制图片的上传类型， file[i].size，限制图片的上传大小，在设置了多选之后，file为一个数组，因此，需要用for循环对每一个进行判断","tags":[{"name":"vue","slug":"vue","permalink":"https://Alansherlock.github.io/tags/vue/"}]},{"title":"搭建shadowsocks","date":"2019-01-15T09:44:54.781Z","path":"2019/01/15/其他/vps搭建shadowsock/","text":"先拉取当前镜像，然后直接复制第一条命令 docker pull mritd/shadowsocks docker run -dt --name ss -p 6443:6443 mritd/shadowsocks -s &quot;-s 0.0.0.0 -p 6443 -m aes-256-cfb -k test123 --fast-open&quot; docker ps查看是否运行成功 docker是啥来着开始的时候，我这个小飞机不是自己搭建的，同事说是学不会的，我就很好奇了，这个时候我通过简单的查看和了解是利用了docker，我做前端的一脸懵逼，只能慢慢百度了解；原来，docker是括号里这个介绍（简介：Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。），装完各种奇怪的镜像后，慢慢就懂了，就是个壳，个壳可以往里塞东西；废话不多说，我们现在来了解下关于docker的基本语法；12345678910111213docker images //查看当前镜像列表，就是有多少个镜像装了docker ps // 查看当前正在跑的镜像docker ps -a //包括了未运行的docker rmi [镜像ID] // 删除当前的镜像，有时候会下载错了docker rm [容器ID] // 删除容器，就是ps列表里的了docker run ..docker start //等等请自行百度，太多了，嘻嘻 docker version简单的介绍了一些命令行我们进入主题，其实我们是用这几条来搞定的，哈哈哈，emmmmm; uname -a检查当前系统版本和内核版本（本人版本是16.04） apt-get install -y docker.io利用Linux安装命令，装docker.io,本人在安装的时候出现了英文，没关系，不懂就翻译；（本人自己在安装的时候提示需要先安装两个依赖，但是在朋友阿里的服务器确是不用的，看着提示来装就好了） 等待安装完毕，现在我们使用下面的命令启动 Docker：systemctl start docker 运行系统引导时启用 docker，命令：systemctl enable docker 拉取镜像安装shadowsocks先拉取当前镜像，然后直接复制第一条命令 docker pull mritd/shadowsocks docker run -dt --name ss -p 6443:6443 mritd/shadowsocks -s &quot;-s 0.0.0.0 -p 6443 -m aes-256-cfb -k test123 --fast-open&quot; docker ps查看是否运行成功","tags":[{"name":"other","slug":"other","permalink":"https://Alansherlock.github.io/tags/other/"}]},{"title":"nginx代理端口，配置https域名","date":"2019-01-15T09:44:54.781Z","path":"2019/01/15/其他/nginx如何配置/","text":"nginx配置 nginx 安装及配置apt-get update apt-get install nginx sudo service nginx reload,或者有其他的命令能启动就行 开始找NGINX配置文件，有可能在root目录下的usr/etc,或者usr/local,这两个找找，ps -ef | grep nginx 查找文件夹路径， vim nginx.conf,进入，点击i,进入编辑，然后在将以下的文件复制进去，以下需要修改的内容有证书编号，还有端口（如果也和我一样就不需要修改8888，其他详细配置请自行百度或者提issue提问我）123456789101112131415161718192021222324252627282930313233343536373839//配置代理的本地端口地址upstream hello &#123; server 127.0.0.1:8888;&#125;server &#123; listen 80; server_name 67.218.151.13; location / &#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Nginx-proxy true; proxy_pass http://hello; proxy_redirect off; &#125;&#125;//配置 https证书，按照阿里云证书下载指南，建立新的代理地址，将location更改为和上面一样server &#123; listen 443; server_name localhost; ssl on; root html; index index.html index.htm; ssl_certificate cert/21477828393053.pem; ssl_certificate_key cert/21477828393053.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Nginx-proxy true; proxy_pass http://hello; proxy_redirect off; &#125;&#125;","tags":[{"name":"nginx","slug":"nginx","permalink":"https://Alansherlock.github.io/tags/nginx/"}]},{"title":"Hello World","date":"2019-01-15T09:44:54.780Z","path":"2019/01/15/其他/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"webpack加快热更新","date":"2019-01-15T09:44:54.780Z","path":"2019/01/15/webpack/wepack加快热更新/","text":"在项目开始的时候，文件还不会很多，我们都没关心热更新的问题，到了大的时候就编译热更新坐在那里等个好久，我说的好久可能大家的都不一样，哈哈哈；接下来，介绍一些小技巧，往后发现就会继续追更，emmm,嘻嘻 技巧一：利用babel-loader缓存参数12345678910111213module.exports = &#123; module: &#123; noParse: /node_modules\\/(jquey|moment|chart\\.js)/, rules: [ &#123; test: /\\.js$/, loader: 'babel-loader?cacheDirectory', include: [resolve('src'), resolve('test')], exclude:/node_modules/ &#125;, ] &#125;&#125; 项目往后需要编译的文件更多，因此我们从babel-loader下手 由于项目开的时候用的是webpack2.x的版本，但是百度后3.x的这个属性依旧是可以用的，会使之前的热更新加快的其中一个点；忽略编译node_modules,使解析babel-loader再快 技巧二：忽略掉一些大的node_modules里面的模块123456module.exports = &#123; module: &#123; //这里列出一些模块，根据自己项目去除一些编译的文件 noParse: /node_modules\\/(jquey|moment|chart\\.js)/, &#125;&#125;","tags":[{"name":"webpack","slug":"webpack","permalink":"https://Alansherlock.github.io/tags/webpack/"}]},{"title":"webpack-todo二","date":"2019-01-15T09:44:54.780Z","path":"2019/01/15/webpack/webpack-todo二/","text":"webpack构建可通用的配置文件 简单的静态资源的基本配置配置时候注意转义点.include:[]12345678910111213141516171819202122232425262728293031323334353637383940414243444546const config = &#123; module: &#123; rules: [ &#123; test:/\\.css$/, loader:'css-loader' &#125;, &#123; test:/\\.vue$/, loader:'vue-loader' &#125;, &#123; test:/\\.css$/, use:[ 'style-loader', 'css-loader' ], include: [] &#125;, //配置处理小的图片 &#123; test:/\\.(gif|jpg|jpeg|png|svg)$/, use:[ &#123; loader:'url-loader', options:&#123; limit:1024, name:'[name].[ext]' &#125; &#125; ] &#125; ], &#125;,&#125;css预处理器loader引入,顺序按照这种处理器loader在后面，然后`css-loader&gt;style-loader`//添加css预处理器&#123; test:/\\.styl/, use:[ 'style-loader', 'css-loader', 'stylus-loader' ]&#125;, 热更新配置热更新配置是利用一个webpack 的插件来配置，在这里我们由于用的是同一份webpack.config.js，所有我们需要区分好生产环境和开发环境；npm i webpack-dev-server cross-env -D,利用cross-env来设置好使用哪个环境 如果不下载cross-env需要利用set配置好window或者是mac系统12345\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"cross-env NODE_ENV=production webpack --config webpack.config.js\", \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js\"&#125;, 书写的时候将利用配置好的启动项来判断是哪个环境1234567891011121314151617181920212223242526const isDev = process.env.NODE.ENV === 'development'const config = &#123; // ....&#125;if(isDev) &#123; //调试时，使代码映射正常代码 config.devTool = '#cheap-module-eval-source-map' config.devServer = &#123; port:8081, //利用0.0.0.0的好处是可以在任意设备上进行热更新 host:'0.0.0.0', //显示错误 overlay :&#123; errors:true &#125;, //启动该项则只更新代码，而输入的那些页面上的数据不会随着代码的改变而消失 hot: true &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125;module.exports = config","tags":[{"name":"webpack","slug":"webpack","permalink":"https://Alansherlock.github.io/tags/webpack/"}]},{"title":"webpack-todo一","date":"2019-01-15T09:44:54.779Z","path":"2019/01/15/webpack/webpack-todo一/","text":"webpack构建可通用的配置文件 搭建开始新建文件夹 webpack-todo 12345678// 进入该文件夹cd webpack-todo// 项目初始化npm init // 下载一些必要的文件，所有的都是用 -D来执行npm i webpack vue-loader vue css-loader -D webpack.config.js书写在根目录新建webpack.config.js,开始配置webpack；由于是使用了webpack4,因此vue-loader需要是以插件的形式来引入到配置环境当中webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path')//webpack4需要引入作为插件使用，区别于2.x,3.x版本const VueLoaderPlugin = require('vue-loader/lib/plugin');module.exports = &#123; mode: \"development\", entry: path.join(__dirname,'src/index.js'), output: &#123; filename: 'bundle.js', path: path.join(__dirname,'dist') &#125;, module: &#123; rules: [ &#123; test:/.css$/, loader:'css-loader' &#125;, &#123; test:/.vue$/, loader:'vue-loader' &#125; ], &#125;, plugins: [ new VueLoaderPlugin() ]&#125;配置webpack打包命令,即npm run build配置package.json的webpack打包命令,即npm run build\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack --config webpack.config.js\"&#125;书写index.jsimport Vue from 'vue'import App from './app.vue'const root = document.createElement('div');document.body.appendChild(root);new Vue(&#123; render:(h)=&gt; h(App)&#125;).$mount(root) app.vue书写新建src做为代码书写目录，开始书写app.vue;由于是以vue结尾的文件，因此我们需要配置vue-loader,来识别该文件由于我们代码里面使用了css-loader,因此需要下载css-loader来解析 12345678910111213141516171819&lt;template&gt; &lt;div id=\"test\"&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return&#123; text:\"abc\" &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; #test &#123; color:red; &#125;&lt;/style&gt;","tags":[{"name":"webpack","slug":"webpack","permalink":"https://Alansherlock.github.io/tags/webpack/"}]},{"title":"vue简单实现响应式","date":"2019-01-15T09:44:54.779Z","path":"2019/01/15/vue/简单实现vue响应式/","text":"看过尤大的vue文档就能知道响应式原理运用的是Object.defineProperty()这个方法；具体的这个方法的解析，可以查看MDN中对Object.defineProperty()的解析， vue简单实现响应式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;简单实现vue响应式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"p\"&gt;&lt;/div&gt; &lt;script&gt; //首先，我们都会围绕着Object.defineProperty，因此这个方法必不可少 // 1. 我们先定义一个函数来接受（data对象，对象的key，对象key值，关于set方法的回调） function defineReactive(obj,key,val,cb,newval) &#123; Object.defineProperty(obj,key,&#123; enumerable:true,//表示可枚举的，如果为false，则在利用for...in...的时候是找不到该属性的 configurable:true,//true该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。 get: ()=&gt;&#123; // console.log(val); return val; &#125;, set: newval =&gt; &#123; //当key被写入新值的时候可以去改变，接着触发我们定义的cd(); if(newval!==val) &#123; val = newval; &#125; cb(); &#125; &#125;) &#125; // 定义一个类名为Vue的 class Vue&#123; constructor(options) &#123; console.log(1); this._data = options.data; observe(this._data,options.render); &#125; &#125; let app = new Vue(&#123; el: '#app', data: &#123; text: 'text', text2: 'text2' &#125;, render()&#123; console.log('this'); &#125; &#125;) function observe(value,cb) &#123; Object.keys(value).forEach((key) =&gt; &#123; // console.log(value); defineReactive(value, key, value[key] , cb)&#125;) &#125; app._data.text2 = 'ceshi'; //更改text2; console.log(app._data.text2); document.querySelector(\".p\").append(app._data.text2+'---'+app._data.text); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://Alansherlock.github.io/tags/vue/"}]},{"title":"对于vue中$nextTick的理解","date":"2019-01-15T09:44:54.779Z","path":"2019/01/15/vue/vue中nextTick/","text":"input输入限制只能输入小数遇到的问题改了我半天发现是需要利用到$nextTick,翻开了下vue的文档关于$nextTick的解释，如下： 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。 要理解的关键概念是DOM是异步更新的。在Vue中更改值时，更改不会立即呈现给DOM。相反，Vue将DOM更新排队，然后在计时器上更新DOM。通常，这种情况发生得如此之快以至于没有什么区别，但是，有时候，你需要在Vue渲染后更新渲染的DOM，你不能立即在方法中做，因为更新没有发生然而。在那些情况下，你会使用nextTick。来自对于$nextTick的理解 为什么会这样？ 看了染陌大佬的$nextTick解析中有这样一段12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt; &lt;div @click=\"handleClick\"&gt;click&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; number: 0 &#125;; &#125;, methods: &#123; handleClick () &#123; for(let i = 0; i &lt; 1000; i++) &#123; this.number++; &#125; &#125; &#125;&#125;&lt;/script&gt; 当我们按下 click 按钮的时候，number 会被循环增加1000次。 那么按照之前的理解，每次 number 被 +1 的时候，都会触发 number 的 setter 方法，从而根据上面的流程一直跑下来最后修改真实 DOM。那么在这个过程中，DOM 会被更新 1000 次！太可怕了。 Vue.js 肯定不会以如此低效的方法来处理。Vue.js在默认情况下，每次触发某个数据的 setter 方法后，对应的 Watcher 对象其实会被 push 进一个队列 queue 中，在下一个 tick 的时候将这个队列 queue 全部拿出来 run（ Watcher 对象的一个方法，用来触发 patch 操作） 一遍。因为目前浏览器平台并没有实现 nextTick 方法，所以 Vue.js 源码中分别用 Promise、setTimeout、setImmediate 等方式在 microtask（或是task）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。——&lt;–摘自染陌掘金小册–&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://Alansherlock.github.io/tags/vue/"}]},{"title":"书写一个react组件","date":"2019-01-15T09:44:54.778Z","path":"2019/01/15/react/如何书写一个react组件/","text":"为什么要写react组件，react简单的组件改如何书写？ 在开始书写一个react组件的时候，我们需要了解到react的一些语法，这样才能在书写的过程中，不会有太多的疑问 就了解，当我书写一个react组件的时候，会有一系列的依赖的引入，最简单的莫过于一定要引入react，import React,{Component} from React;这个是在写react哪个组件都要引入的react的依赖，紧接着，你可能还需要一些css也可以通过import的方式来引入到我们的组件当中，有一点需要注意的是，在引入的css样式中，我们需要用一个根标签来包住,防止在书写的时候被其他地方的样式污染； react16的&lt;Fragment&gt;&lt;/Fragment&gt; 书写react，外围有时候需要用一个标签来包住，这个时候我们就可以像引入Component一样引入这个标签包裹在需要一个虚拟的div的地方，从而不会影响页面的布局","tags":[{"name":"react","slug":"react","permalink":"https://Alansherlock.github.io/tags/react/"}]},{"title":"decorator","date":"2019-01-15T09:44:54.778Z","path":"2019/01/15/js/装饰器/","text":"decorator(装饰器)配置demo环境12345678910&#123; \"scripts\": &#123; \"babel-version\": \"babel --version\" &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.26.0\", \"babel-plugin-transform-decorators-legacy\": \"^1.3.5\", \"babel-register\": \"^6.26.0\" &#125;&#125; demo1 创建APP.js 123456789// 装饰器@testclass hello &#123;&#125;// 利用这个东西可以为类hello添加新的属性或者改变里面的属性function test(target) &#123; // target为楼上的hello类 target.isT = true;&#125;console.log(hello.isT); 创建complie.js 因为demo是利用node直接运行，因此利用babel-register来使node环境能跑 1234require('babel-register')(&#123; plugins: ['transform-decorators-legacy']&#125;);require(\"./app.js\") 理解decorator1234567@decoratorclass hello &#123;&#125;//楼上的写法即是楼下这种，装饰器修饰了一下再继续返回给了类helloclass hello &#123;&#125;hello = decorator(hello) || hello; demo2[装饰器传参]依旧是写在app.js,然后执行node complie.js12345678910111213141516171819// 为value传入true@value(true)class demoOne&#123;&#125;// 在这一种有参数的情况下，我们使用了两层嵌套的方式，先传入了装饰器带的值，然后再return一个函数来用于处理我们需要装饰的类demoOne,target依旧是我们定义的类function value(val) &#123; return function(target) &#123; target.isTable = val; &#125;&#125;console.log(demoOne.isTable)// true// 为value传入false@value(false)class demoTwo&#123;&#125;function value(val) &#123; return function(target) &#123; target.isTable = val; &#125;&#125;console.log(demoTwo.isTable)// false demo3[装饰器添加实例属性]12345678910@objectTestclass helloTest &#123;&#125;// 利用这个东西可以为类hello添加新的属性或者改变里面的属性function objectTest(target) &#123; // target为楼上的hello类 target.prototype.isTable = true;&#125;let newhelloTest = new helloTest();console.log(helloTest.isTable,newhelloTest.isTable);// undefine,true 以上是装饰器对类的处理，装饰器还有修饰类的属性等功能。。。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Alansherlock.github.io/tags/JavaScript/"}]},{"title":"react使用笔记","date":"2019-01-15T09:44:54.778Z","path":"2019/01/15/react/react小笔记/","text":"对于react初步使用的总结 react 使用react 中this指向问题在使用react的时候，开始的时候因为this指向的问题用了bind，然而可以使用e =&gt; {this.tabClick}这种来让this的指向指向定义的那个类，减少代码量 react中判断语句一般采用三元表达式来作判断在react中，类似vue指令v-if的写法则是{true?use this: use this},这种来判断； react 中循环的写法在循环上，则需要定义好map方法，须记得return 出来当前书写完的这些 获取地址栏参数1this.props.location.query;// query则可以拿到一个对象，这个对象包含了传递的参数 【场景：mobx+react】 react 导入HTML123&lt;div className='description'&gt; &lt;p dangerouslySetInnerHTML=&#123;&#123; __html: activityDetail.content &#125;&#125; /&gt;&lt;/div&gt; react 虚拟标签(本人叫法，有点类似Vue里面经常使用的template标签)1234&#123;x.imageUrl ?&lt;Fragment&gt; &lt;img src=&#123;x.imageUrl&#125; style=&#123;&#123; width: '90%' &#125;&#125; alt=\"图片查看\" /&gt;&lt;br /&gt;&lt;/Fragment&gt; : null&#125;","tags":[{"name":"react","slug":"react","permalink":"https://Alansherlock.github.io/tags/react/"}]},{"title":"react基础知识","date":"2019-01-15T09:44:54.778Z","path":"2019/01/15/react/react基础/","text":"更新数据的this.setState()在日常使用中，都是直接就this.setState()，里面包裹着一个对象然后直接的更新好数据例如：1this.setState(&#123;isTrue:true&#125;); 然后，在一些场景中，由于数据量大，保存的时候会因为没存储完就立马去调用下一步操作，这个时候，我也尝试了 async + await,ES7中异步的操作，但是还是没啥变化，最后在查阅资料的过程中，发现this.setState()还可以有函数的参数，例如：123this.setState(&#123;isTrue:true&#125;,()=&gt; &#123; // 在这里做一些存储完数据后的操作&#125;); 在react后续的版本中，setState方法还可以是函数的形式，例如：123456this.setState( // 这样也能达到更新值的目的，两个参数，在一些异步的场景说会用到 (prevState, props) =&gt; ( &#123; count: prevState.count + 1 &#125; )); {true?true:false}(三元表达式) || &amp;&amp;12345678910111213141516171819/* 三元表达式 比较了vue 和 react的函数式三元判断，还是觉得Vue的舒服些**/&#123;isLoading ? &lt;div className=\"empty\"&gt;数据加载中...&lt;/div&gt; : \"\"&#125;/*或字符 || 好像这个在HTML中少用到，数据上倒是经常**/&#123;activityLists == null || activityLists.length == 0 &amp;&amp; &lt;div className=\"empty\"&gt;暂无活动~&lt;/div&gt;&#125;/*&amp;&amp;在看了人家的代码才知道这个也可以搞起来，没必要天天用三元运算符**/&#123;activityList.total &gt; 10 &amp;&amp; loadEnd &amp;&amp; ( &lt;div className=\"empty\"&gt;数据加载完毕&lt;/div&gt;)&#125; 跳转路由的方式在日常的框架中，都有一个是直接就跳转能够存储到，还有一个replace直接不能后退，如下写法： 123456789101112this.props.router.pushthis.props.router.replace// 在使用的过程中，可以在入口中直接定义好，可以简短些书写，如下：componentWillMount() &#123; window.app = &#123; goto: this.props.router.push, replace: this.props.router.replace &#125;;&#125;// 在其他地方的写法，则可以直接是如下：window.app.goto('login');window.app.replace('login'); 路由的写法在接触的移动端中，路由用的4，写法感觉和之前Vue的路由大同小异，如下： 在引入入口的render中就开始书写上router,如下：123456789101112// Stores 和 Routes 的初始化// 使用React-Router 3 效果会更好import &#123; Router, hashHistory &#125; from \"react-router\";// 导入Providerimport &#123; Provider &#125; from \"mobx-react\";const rootEl = document.getElementById(\"root\");render( &lt;Provider &#123;...Stores&#125;&gt; &lt;Router history=&#123;hashHistory&#125; routes=&#123;routes&#125; /&gt; &lt;/Provider&gt;, rootEl); 接下来则是引入路由的路径1234567891011121314151617181920212223242526272829303132333435363738394041 import App from \"./App\";import &#123; uservistIng &#125; from './biz/home/index/userVistIngServ'function setTitle(title) &#123; window.document.title = title;&#125;// 进入路由之前的处理，检查是否已登录const beforeEnter = async (nextState, replace, next) =&gt; &#123; await uservisits(); next()&#125;async function uservisits() &#123; await uservistIng();&#125;export default [ &#123; path: \"/\", component: App, indexRoute: &#123; onEnter: (nextState, replace) =&gt; replace(\"/home\") &#125;, childRoutes: [ &#123; path: \"home\", getComponent: (nextState, cb) =&gt; &#123; setTitle(\"长安汽车尊享服务\"); import(\"biz/home/index/IndexView\").then(x =&gt; &#123; cb(null, x.default); &#125;); &#125;, onEnter: beforeEnter &#125;, &#123; path: \"chat\", title: \"VIP服务室\", getComponent: (nextState, cb) =&gt; &#123; import(\"biz/home/chat/IndexView\").then(x =&gt; &#123; cb(null, x.default); &#125;); &#125;, onEnter: beforeEnter &#125; ] &#125;","tags":[{"name":"react","slug":"react","permalink":"https://Alansherlock.github.io/tags/react/"}]},{"title":"canvas水印","date":"2019-01-15T09:44:54.777Z","path":"2019/01/15/canvas/canvas水印/","text":"上次写了canvas水印现在整理下，方便下次需要拿取出来使用，也可以供封装为组件 ##canvas水印 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;template&gt; &lt;div id=\"watermark\"&gt; &lt;canvas id=\"canvas\" height='100%' width='100%'&gt; 你的浏览器不支持canvas,请升级你的浏览器 &lt;/canvas&gt; &lt;canvas id=\"repeat-watermark\" height='100%' width='100%'&gt; 你的浏览器不支持canvas,请升级你的浏览器 &lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; &#125; &#125;, component: &#123; &#125;, async mounted() &#123; await this.loadWatermark(); await this.getWatermark(); &#125;, methods:&#123; // 先制作小水印 loadWatermark() &#123; let canvas = document.getElementById('canvas'); if (!canvas.getContext) return; // 小画布的宽高 canvas.height = 100; canvas.width = 100; let ctx = canvas.getContext('2d'); ctx.clearRect(0,0,160,100); //绘制之前画布清除 ctx.font=\"20px 黑体\"; ctx.rotate(-20*Math.PI/180); ctx.fillStyle = \"rgba(100,100,100,0.1)\"; ctx.fillText(\"刘泽浩\", -20, 80); ctx.rotate('20*Math.PI/180'); //坐标系还原 &#125;, getWatermark() &#123; // 平铺满整个容器 let crw = document.getElementById('repeat-watermark'); let canvas = document.getElementById('canvas'); if (!crw.getContext) return; // 整个容器的宽高 let height = document.getElementById('watermark').offsetHeight; let width= document.getElementById('watermark').offsetWidth; crw.width = width; crw.height = height; let ctxr = crw.getContext(\"2d\"); ctxr.clearRect(0,0,crw.width,crw.height); //清除整个画布 \\ //主要是这个API let pat = ctxr.createPattern(canvas, \"repeat\"); //在指定的方向上重复指定的元素 ctxr.fillStyle = pat; ctxr.fillRect(0, 0, crw.width, crw.height); &#125; &#125;,&#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;#watermark &#123; position: relative; width: 100%; height: 100%;&#125;#repeat-watermark&#123; position:absolute; top:0; z-index:10; background: #fff;&#125;&lt;/style&gt; emmm","tags":[{"name":"canvas","slug":"canvas","permalink":"https://Alansherlock.github.io/tags/canvas/"}]},{"title":"js数组常用方法","date":"2019-01-15T09:44:54.777Z","path":"2019/01/15/js/js数组常用方法/","text":"不改变原数组，返回新数组的方法concat() 合并两个数组123456789101112131415161718192021let arr1 = [1,2,3];let arr2 = [4,5,6];let twoArr = [1,[2]]let arr3 = arr1.concat(arr2);let arr4 = arr2.concat(arr1);let arr5 = arr1.concat(twoArr);console.log(arr1,arr2,arr3,arr4,arr5);// [ 1, 2, 3 ] [ 4, 5, 6 ] [ 1, 2, 3, 4, 5, 6 ] [ 4, 5, 6, 1, 2, 3 ] [ 1, 2, 3, 1, [ 2 ] ]``` ### join()&gt; 合并为字符串``` JavaScriptlet joinArr1 = [1,2,'A','B']let joinArr2 = [3,4,'c','d']let join1 = joinArr1.join('');let join2 = joinArr2.join('');console.log(join1,join2);// 12AB 34cd slice()123456789let sliceArr1 = [1,2,3,4,5,6];let sliceArr2 = ['A','B','C','D'];let sliceStr = 'abcdef'let slice1 = sliceArr1.slice(1,2);let slice2 = sliceArr2.slice(1,3);let slice3 = sliceStr.slice(1,3);//字符串的则是单个数如果是负数从后面截取let slice4 = sliceStr.slice(-2);console.log(slice1,slice2,slice3,slice4); every() 执行一个回调函数，如果数组中有一个不满足，则every返回false，都满足则返回true； 1234567let evArr = [1,2,3];let every1 = evArr.every((e)=&gt; &#123; console.log(e,'e'); // 在这里记得是需要return的，e表示数组循环出来的每个值 return e &lt; 4&#125;)console.log(every1); map()1234567let mapArr = [1,2,3,4];let map1 = mapArr.map((a,index,c) =&gt; &#123; // 参数一为值，参数二为索引，参数三为原数组 console.log(a,index,c) return a + 1;&#125;)console.log(map1) some() 除非全部不满足，否则则还是为true123456let someArr = [1,2,3];let some1 = someArr.some((e)=&gt; &#123; return e &lt;2;&#125;);console.log(some1);// true filter() 返回了满足的新数组123let filterArr = [1,2,3];let filter1 = filterArr.filter((e)=&gt; e &lt;2);console.log(filter1);//[ 1 ] 改变原数组的方法forEach()pop()push()reverse()shift()unshift()sort()splice()数组去重reduce去重12345678910const distinct = arr =&gt; arr.sort().reduce( (init, current) =&gt; &#123; if (init.length === 0 || init[init.length - 1] !== current) &#123; init.push( current ); &#125; return init;&#125;, []);let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];distinct(arr); // [1, 2, 3, 4, 5] filter去重123456const distinct = arr =&gt; arr.filter( (element, index, self) =&gt; &#123; return self.indexOf( element ) === index;&#125;);let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];distinct(arr); // [1, 2, 3, 5, 4] 多维数组降维12345const flattenDeep = arr =&gt; Array.isArray(arr) ? arr.reduce( (a, b) =&gt; [...a, ...flattenDeep(b)] , []) : [arr]flattenDeep([1, [[2], [3, [4]], 5]]); // [1, 2, 3, 4, 5]","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Alansherlock.github.io/tags/JavaScript/"}]},{"title":"了解WEB及网络基础","date":"2019-01-15T09:44:54.777Z","path":"2019/01/15/http图解/http/","text":"开始看Http图解了，上次就大概在手机上看了下，没做笔记了解的其实也不深入,先从网络基础开始学习。 使用Http协议访问WEB 当在浏览器输入URL后发生了什么？ 在日常的操作中，输入后就会有个页面展示出来，但是这个可以再往深入一点，输入后点击请求的这边叫客户端，然后连接到另外一边的服务器，服务器再响应回来数据从而有数据展示； 这种通过发送请求获取服务器资源的 Web 浏览器等，都可称为客 户端（client） Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协 议 1）的协议作为规范，完成从客户端到服务器端等一系列运作流 程。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通 信的。 HTTP 的诞生好像不想了解，一堆历史，虽然吹水好像蛮有用，emmmm; HTTP/0.9 HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准被建立。 现在的 HTTP 其实含有 HTTP1.0 之前版本的意思，因此被称为 HTTP/0.9。 HTTP/1.0 HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为 HTTP/1.0，并记载于 RFC1945。虽说是初期标准，但该协议标准至今 仍被广泛使用在服务器端。 HTTP/1.1 1997 年 1 月公布的 HTTP/1.1 是目前主流的 HTTP 协议版本。当初的 标准是 RFC2068，之后发布的修订版 RFC2616 就是当前的最新版本。 后续还有http2.0等一些新协议诞生… TCP/IP 协议族 协议的定义 如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为 协议（protocol） 上图为TCP/IP 的集合，TCP/IP 实际上并不只有TCP/IP 这两种，但在日常也有一些人直接用来表示TCP/IP这两种协议； TCP/IP 的分层管理 TCP/IP 协议族按层次分别分 为以下 4 层：应用层、传输层、网络层和数据链路层。如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分 层之后只需把变动的层替换掉即可。(理解则是互相之间耦合度不会高，在调整和修改的过程中工作量和复杂度降低，方便操作) 应用层 决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域 名系统）服务就是其中两类。HTTP 协议也处于应用层。 传输层 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据 传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报 协议）。 网络层（又名网络互连层） 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计 算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是在众多的选项内选择一条传输路线。 链路层（又名数据链路层，网络接口层） 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在 链路层的作用范围之内。 TCP/IP 通信传输流 如上图，这图画的贼清楚，顺便表达了我的内心想法，哈哈哈,先从客户端出来再进去服务器，再从服务器出来再进客户端；我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层 （HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数 据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端 口号后转发给网络层。在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链 路层。这样一来，发往网络的通信请求就准备齐全了。接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用 层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该 层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）。 与 HTTP 关系密切的协议 : IP、TCP 和 DNS IP是一种协议，位于网络层；区别于平常说的IP地址，而IP传输又必须有传输需要的地址 IP地址和MAC地址，IP地址会变，MAC地址基本不变；IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定 地址。 ARP 是一种用以解析地址的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址,以下为ARP协议的解析图 TCP 协议， TCP协议位于传输层，提供可靠的字节流服务； 所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大 块数据分割成以报文段（segment）为单位的数据包进行管理。TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够 确认数据最终是否送达到对方,采用的是 三次握手 来确认。 握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。 发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发 送端再回传一个带 ACK 标志的数据包，代表“握手”结束。 负责域名解析的 DNS 服务 DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的 协议。它提供域名到 IP 地址之间的解析服务。DNS 协议提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务 URL 和URIURI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。 URI 格式 表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL 以 及相对 URL。相对 URL，是指从浏览器中基本 URI 处指定的 URL，形如 /image/logo.gif。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://Alansherlock.github.io/tags/HTTP/"}]},{"title":"scrapy","date":"2019-01-15T09:44:54.776Z","path":"2019/01/15/Python/scrapy/scrapy小实践/","text":"搞起来，scrapy 安装完scrapy后，开始初始化项目 12# 初始化项目名为examplescrapy startobject example 直接开始书写爬虫的Spider文件，在spiders中建立book_spider.py,书写以下代码来抓取全书网的某页的书籍名称和书籍作者，然后保存一个csv文件 123456789101112131415161718192021222324# 引入框架import scrapyclass BooksSpider(scrapy.Spider): #爬虫唯一名称 name = 'books' # 爬取的网页，可爬取多个 start_urls = ['http://www.quanshuwang.com/list/1_1.html'] # 定义对爬取响应回来的内容做处理 def parse(self,response): # 爬取的是当前这个列表，需要定义的css从根节点开始，即 li标签 for book in response.css('.seeWell.cf li'): # xpath 语法 name = book.xpath('./span/a/@title').extract_first() # css语法 author = book.css('span a:nth-child(2)::text').extract_first() # 处理返回 name和author yield &#123; 'name':name, 'author':author &#125; # 这段是可以的，但是由于数据太多抓取困难，卡死了，回头再研究下 # next_url = response.css('.pages .pagelink a::attr(href)').extract_first() # if next_url: # yield scrapy.Request(url=next_url, callback=self.parse) 执行scrapy crawl books -o books.csv,即可生成对应的books.csv文件4.其他的内容下次继续。。。","tags":[{"name":"Python","slug":"Python","permalink":"https://Alansherlock.github.io/tags/Python/"}]},{"title":"scrapy","date":"2019-01-15T09:44:54.776Z","path":"2019/01/15/Python/scrapy/scrapy笔记/","text":"安装scrapy pip install scrapy (还可以用pip3) 遇到pip版本过低的，跟着提示升级即可python -m pip install --upgrade pip pip install scrapy 在第三步的时候，提示安装编译器error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Microsoft Visual C++ Build Tools&quot;: http://landinghub.visualstudio.com/visual-cpp-build-tools,还有这个mysql-connector-python 8.0.13 requires protobuf&gt;=3.0.0, which is not installed.A. 这个时候我们不需要去安装编译器，而是安装另外一个依赖包即可 twisted相关包地址，在twisted这一栏下载对应的依赖包到自己电脑，然后找到你下载好的文件路径，例如我的文件下载到了D:\\Python\\Twisted-18.9.0-cp37-cp37m-win_amd64.whl,在cmd继续运行 pip install D:\\Python\\Twisted-18.9.0-cp37-cp37m-win_amd64.whl,当最后报Successfully installed Twisted-18.9.0,即可进行安装scrapy，pip install scrapy,报Successfully installed Scrapy-1.5.1,即是安装成功；B. mysql-connector-python 8.0.13这个则直接pip install mysql-connector-python 8.0.13即可 scrapy解析组件解析 engine,框架核心，其他组件在其控制下协同工作（内部组件） scheduler,调度器，负责对spider提交的下载请求进行调度 downloader,下载器，负责下载页面（发送HTTP请求/接受HTTP响应）（内部组件） spider,爬虫，负责提取页面中的数据，并产生对新页面的下载请求（用户实现） middleware,中间件，负责对Request对象和Response对象进行处理（内容组件） item pipeline,数据管道，负责对爬取到的数据进行处理（内部组件） 数据流 Request，scrapy的请求对象 Response，scrapy的响应对象 ITEM，从页面爬取的一项数据 Request对象一般情况下只有这两个参数，其他可选（method,headers,body,cookies,meta,encoding,priority = 0,dont_filter=False, errback）priority,请求优先级,默认为01yield scrapy.Request(url=next_url, callback=self.parse) Response对象headers，这个可以通过get方法进行访问里面的数据，12response.headers.get('Content-Type')response.headers.get('Set-Cookie') Selector对象可以供使用的有Xpath和css两种语法的代码，12# 选择文档中的h1标签，有多个则拼成数组selector_list = selector.xpath('//h1') 使用这个对象提取数据的方法有extract_first(),re_first(),前提是数组哈，不是数组的用另外的这两个extract(),re()re这种写法是搞正则匹配的，re_first(&#39;\\d+\\.\\d+&#39;),提取小数点左右的数字； ###XPath","tags":[{"name":"Python","slug":"Python","permalink":"https://Alansherlock.github.io/tags/Python/"}]},{"title":"玩玩canvas","date":"2019-01-15T09:44:54.776Z","path":"2019/01/15/canvas/canvas/","text":"1&lt;canvas id=\"tutorial\" width=\"300\" height=\"300\"&gt;&lt;/canvas&gt; canvas 在初始化宽高的时候建议不用css设置，如果设置的比例和初始的比例不同，则会造成扭曲，因此在开始的时候有两种写法： 一种在标签直接加 width,height; 一种是在获取完canvas标签节点后，在js给它加上宽高；1234let canvas = document.getElementById('canvas');if (!canvas.getContext) return;canvas.height = 100;canvas.width = 100; 绘制矩形 fillRect(x, y, width, height)绘制一个填充的矩形 strokeRect(x, y, width, height)绘制一个矩形的边框 clearRect(x, y, widh, height)清除指定的矩形区域，然后这块区域会变的完全透明。 1234567let ctx = canvas.getContext('2d');// 绘制填充矩形ctx.fillRect(10, 10, 100, 50);// 绘制矩形边框ctx.strokeRect(10, 70, 100, 50); // 清除矩形ctx.clearRect(15, 15, 50, 25); 绘制路径在每次画完一条路径后就要closePath(),不然会影响下一个路径的绘制 beginPath()新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径 moveTo(x, y)把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。 closePath()闭合路径之后，图形绘制命令又重新指向到上下文中 stroke()通过线条来绘制图形轮廓 fill()通过填充路径的内容区域生成实心的图形 绘制圆弧 arc(x, y, r, startAngle, endAngle, anticlockwise) x,y为坐标点，r为半径，startAngle，endAngle为角度，anticlockwise为绘制的方向，true为逆时针；","tags":[{"name":"canvas","slug":"canvas","permalink":"https://Alansherlock.github.io/tags/canvas/"}]},{"title":"canvas刮刮乐","date":"2019-01-15T09:44:54.776Z","path":"2019/01/15/canvas/canvas刮刮乐/","text":"上次写了canvas刮刮乐现在整理下，方便下次需要拿取出来使用，也可以供封装为组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;template&gt;&lt;div class=\"guaguale\"&gt; &lt;p&gt;一等奖&lt;/p&gt; &lt;canvas id=\"canvas\" width=\"500\" height=\"1000\" @mousedown=\"down\" @mouseup=\"up\" @mousemove=\"move\" &gt; 您的浏览器不支持canvas！ &lt;/canvas&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; flag:false, lx:'', ly:'' &#125; &#125;, mounted() &#123; this.guagua(); &#125;, methods:&#123; guagua() &#123; let cv = document.getElementById(\"canvas\"), p = document.getElementsByTagName(\"p\")[0]; //设置中奖几率 let num = 10000 * Math.random(), result = \"\"; if (num &lt; 1000) &#123; // result = \"三等奖\"; &#125; if (num &lt; 50) &#123; // result = \"二等奖\"; &#125; if (num &lt; 5) &#123; // result = \"一等奖\"; &#125; p.innerText = result; try &#123; let ct = cv.getContext(\"2d\"); //绘制背景色 ct.fillStyle = \"skyblue\"; ct.fillRect(0, 0, 500, 1000); //设置绘制状态 ct.lineCap = \"round\"; //设置线条两端为圆弧 ct.lineJoin = \"round\"; //设置线条转折为圆弧 ct.lineWidth = 60; /*设置新绘制清除新绘制内容和原内容的重叠区域*/ ct.globalCompositeOperation = \"destination-out\"; &#125; catch (e) &#123; console.log(e); &#125; &#125;, down(e) &#123; this.flag = true; this.lx = e.offsetX; this.ly = e.offsetY; &#125;, up() &#123; this.flag = false; &#125;, move(e) &#123; if (this.flag) &#123; let cv = document.getElementById(\"canvas\"); let ct = cv.getContext(\"2d\"); ct.beginPath(); ct.moveTo(this.lx, this.ly); ct.lineTo(e.offsetX, e.offsetY); ct.stroke(); ct.closePath(); //更新坐标 this.lx = e.offsetX; this.ly = e.offsetY; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt; #canvas &#123; /* canvas 默认宽高 300*150 css设置的宽高，只能设置canvas对象在页面显示的大小。 并不能增加画布内部的像素数 */ border: 1px solid black; /* width: 500px; height: 500px; */ margin: 0 auto; position: absolute; left: 0; top: 0; &#125; .guaguale &#123; width: 500px; height: 500px; background: url(\"../../assets/dou.png\") no-repeat; background-size: 100% 100%; position: relative; &#125; .guaguale p &#123; font-size: 50px; line-height: 500px; text-align: center; width: 100%; &#125;&lt;/style&gt;","tags":[{"name":"canvas","slug":"canvas","permalink":"https://Alansherlock.github.io/tags/canvas/"}]}]